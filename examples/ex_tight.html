<p>
C&eacute;u ensures at compile time that a trail never runs forever, and hence, 
that reaction chains always run to completion in <span class="label 
label-info">bounded time</span>.
</p>

<p>
The compiler detects and refuses the only way a trails can run in unbounded 
time: loops that do not await, the so called <span class="label 
label-info">tight loops</span>.
</p>

<p>
In the following examples, which are all refused at compile time, 
the loop bodies have at least one path that does not await:
</p>

<pre>
loop do               // a tight loop
  nothing;            // 'nothing' is a valid statement :)
end
</pre>

<p>or</p>

<pre>
loop do             // a tight loop
  par/or do
    await A;
  with
    nothing;        // this path does not await
  end
end
</pre>

<p>or</p>

<pre>
loop do               // a tight loop
  if a == 0 then
    await A;
  end                 // the omitted else does not await
end
</pre>

<blockquote>
	<p><i>C&eacute;u detects tight loops at compile time!</i></p>
</blockquote>

<p>
The example in the code panel calculates the factorial of <code>10</code>, but 
contains a tight loop and is also refused. (try it!)
</p>

<p>
This example is actually useful and it would be a shame if it couldn't be 
written in C&eacute;u.
We return to it on <a href="try.php?sample=ex_async10">lesson 19</a>.
</p>

<p>
The tight loop analysis is not extended for external C code.
Hence, it is the responsibility of the programmer to ensure that external 
functions run in bounded time.
</p>
