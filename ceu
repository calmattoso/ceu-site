#!/usr/bin/env lua

--[[
-- This file is automatically generated.
-- Check the github repository for a readable version:
-- http://github.com/fsantanna/ceu
--
-- Céu is distributed under the MIT License:
--

Copyright (C) 2012 Francisco Sant'Anna

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

--
--]]

_OPTS = {
    input     = nil,
    output    = '_ceu_code.cceu',

    defs_file  = '_ceu_defs.h',

    join      = true,
    c_calls   = false,

    cpp       = true,
    cpp_args  = false,

    --m4        = false,
    --m4_args   = false,

    tp_word    = 4,
}

_OPTS_NPARAMS = {
    input     = nil,
    output    = 1,

    defs_file  = 1,

    join      = 0,
    c_calls   = 1,

    cpp       = 0,
    cpp_args  = 1,

-- TODO: remove
    --m4        = 0,
    --m4_args   = 1,

    tp_word    = 1,
}

local params = {...}
local i = 1
while i <= #params
do
    local p = params[i]
    i = i + 1

    if p == '-' then
        _OPTS.input = '-'

    elseif string.sub(p, 1, 2) == '--' then
        local no = false
        local opt = string.gsub(string.sub(p,3), '%-', '_')
        if string.find(opt, '^no_') then
            no = true
            opt = string.sub(opt, 4)
        end
        if _OPTS_NPARAMS[opt]==0 or _OPTS_NPARAMS[opt]==nil then
            _OPTS[opt] = not no
        else
            local opt = string.gsub(string.sub(p,3), '%-', '_')
            _OPTS[opt] = string.match(params[i], "%'?(.*)%'?")
            i = i + 1
        end

    else
        _OPTS.input = p
    end
end
if not _OPTS.input then
    io.stderr:write([[

    ./ceu <filename>           # Ceu input file, or `-´ for stdin
    
        --output <filename>    # C output file (stdout)
    
        --defs-file <filename> # define constants in a separate output file (no)

        --join (--no-join)     # join lines enclosed by /*{-{*/ and /*}-}*/ (join)
        --c-calls              # TODO

        --cpp (--no-cpp)       # preprocess the input with `cpp´ (no-cpp)
        --cpp-args             # preprocess the input with `cpp´ passing arguments in between `"´ (no)

        --tp-word              # sizeof a word in bytes    (4)

]])
    os.exit(1)
end

-- TODO: remove
        --m4 (--no-m4)         # preprocess the input with `m4´ (no-m4)
        --m4-args              # preprocess the input with `m4´ passing arguments in between `"´ (no)

-- C_CALLS
if _OPTS.c_calls then
    local t = {}
    for v in string.gmatch(_OPTS.c_calls, "([_%w]+)") do
        t[v] = true
    end
    _OPTS.c_calls = t
end


-- INPUT
local inp
if _OPTS.input == '-' then
    inp = io.stdin
else
    inp = assert(io.open(_OPTS.input))
end
local source = inp:read'*a'

-- TODO: remove
--[[
if _OPTS.m4 or _OPTS.m4_args then
    local args = _OPTS.m4_args or ''
    local m4_file = (_OPTS.input=='-' and '_ceu_tmp.ceu_m4') or _OPTS.input..'_m4'
    local m4 = assert(io.popen('m4 '..args..' - > '..m4_file, 'w'))
    m4:write(source)
    m4:close()

    source = assert(io.open(m4_file)):read'*a'
    --os.remove(m4_file)
end
]]

_OPTS.source = source

-- PARSE
do
    
do
_TP = {}

local types = {
    void=true,
    int=true,
    u64=true, s64=true,
    u32=true, s32=true,
    u16=true, s16=true,
    u8=true,  s8=true,
}

-- len aligned to word size
function _TP.sizeof (len)
    local al = len
    if al > _ENV.c.word.len then
        al = _ENV.c.word.len   -- maximum adjust is the word size
    end
    local r = len % al
    if r > 0 then
        len = len + (al-r)
    end
    return len
end

-- returns off/aligned + len
function _TP.align (off, len)
    if len > _ENV.c.word.len then
        len = _ENV.c.word.len   -- maximum adjust is the word size
    elseif len == 0 then
        len = 1                 -- minimum alignment (TODO: why?)
    end
    local r = off % len
    if r > 0 then
        off = off + (len-r)
    end
    return off
end


function _TP.n2bytes (n)
    if n < 2^8 then
        return 1
    elseif n < 2^16 then
        return 2
    elseif n < 2^32 then
        return 4
    end
    error'out of bounds'
end

function _TP.ceil (v)
    local w = _OPTS.tp_word
    while true do
        if v % w == 0 then
            return v
        else
            v = v + 1
        end
    end
end

-- TODO: enforce passing parameter `c´ to isNumeric/deref/contains/max ?

function _TP.noptr (tp)
    return (string.match(tp, '^([^%*]*)%**'))
end

--[[
function _TP.c (tp)
    -- _tp->tp
    -- class->CEU_XXX
    -- class*->CEU_XXX* (too!)
    return (string.gsub(string.gsub(tp,'^%u[_%w]*%*?','char*'), '^_', ''))
end
]]

function _TP.isTuple (tp)
    return _ENV.c[tp] and _ENV.c[tp].tuple
end

function _TP.c (tp)
    local cls = _ENV.clss[_TP.noptr(tp)]
    if cls then
        return 'CEU_'..tp
    end

    return (string.gsub(tp,'^_', ''))
end

function _TP.isNumeric (tp, c)
    return tp~='void' and types[tp] or (c and _TP.ext(tp,c))
end

function _TP.deref (tp, c)
    return string.match(tp,'(.-)%*$') or (c and _TP.ext(tp,c))
end

function _TP.ext (tp, loc)
    return (tp=='_' and '_') or
           (loc and (not _TP.deref(tp)) and (string.sub(tp,1,1) == '_') and tp)
end

function _TP.contains (tp1, tp2, c)
    -- same exact type
    if tp1 == tp2 then
        return true
    end

    -- both are numeric
    if _TP.isNumeric(tp1,c) and _TP.isNumeric(tp2,c) then
        return true
    end

    -- both are pointers
    local _tp1, _tp2 = _TP.deref(tp1,c), _TP.deref(tp2,c)
    if _tp1 and _tp2 then
        local cls1 = _ENV.clss[_tp1]
        local cls2 = _ENV.clss[_tp2]
        -- assigning to a cls (cast is enforced)
        if cls1 then
            return tp2 == 'null*' or
                   cls2 and cls1.is_ifc and _ENV.ifc_vs_cls(cls1,cls2)
        end
        return tp1=='void*' or tp2=='void*' or tp2=='null*'
                or c and (tp1=='_' or tp2=='_')
                or _TP.contains(_tp1, _tp2, c)
    end

    -- c=accept ext // and at least one is ext
    if c and (_TP.ext(tp1) or _TP.ext(tp2)) then
        return true
    end

    -- both are tuples
    local tup1 = _TP.isTuple(tp1)
    local tup2 = _TP.isTuple(tp2)
    if tup1 and tup2 and (#tp1 == #tp2) then
        for i=1, #tp1 do
            if not _TP.contains(tp1[i], tp2[i]) then
                return false
            end
        end
        return true
    end

    return false
end

function _TP.max (tp1, tp2, c)
    if _TP.contains(tp1, tp2, c) then
        return tp1
    elseif _TP.contains(tp2, tp1, c) then
        return tp2
    else
        return nil
    end
end

end

    
do
m = require 'lpeg'
m.setmaxstack(1000)

local CNT  = 1
local LINE = 1
local FILE = _OPTS.input
local patt

_LINES = {
    i2l = {},
}

local open = m.Cmt('/*{-{*/',
    function ()
        if _OPTS.join then
            CNT = CNT - 1
        end
        return true
    end )
local close = m.Cmt('/*}-}*/',
    function ()
        if _OPTS.join then
            CNT = CNT + 1
        end
        return true
    end )

local line = m.Cmt('\n',
    function (s,i)
        for i=#_LINES.i2l, i do
            _LINES.i2l[i] = { FILE, LINE }
        end
        if CNT > 0 then
            LINE = LINE + 1
        end
        return true
    end )

local S = (m.S'\t\r ' + m.P'\\'*(1-m.P'\n')^0*'\n')
local SS = S^0

-- #line N "file" :: directive to set line/filename
local dir_lins = m.Cmt( m.P'#' *SS* m.P'line'^-1
                          *SS* m.C(m.R'09'^1)             -- line
                          *SS* ( m.P'"' * m.C((1-m.P'"')^0) * m.P'"'
                              + m.Cc(false) )            -- file
                          * (S + (m.P(1)-'\n'))^0 * '\n' -- \n
                 ,
    function (s,i, line, file)
        LINE = line
        FILE = file
        return true
    end )

patt = (line + open + close + dir_lins + 1)^0

_OPTS.source = '#line 1 "'.._OPTS.input..'"\n'.._OPTS.source

if _OPTS.cpp or _OPTS.cpp_args then
    local args = _OPTS.cpp_args or ''
    local orig = (_OPTS.input=='-' and 'tmp.ceu')
                    or _OPTS.input
    local base, name = string.match(orig, '(.*/)(.*)')
    if not base then
        base = ''
        name = orig
    end

    -- fin, fout, ferr
    local fout = base..'_ceu_cpp_'..name
    local ferr = fout..'.err'
    local fin  = fout..'.in'
    local f = assert( io.open(fin,'w') )
    f:write(_OPTS.source)
    f:close()

    -- execute cpp
    local ret = os.execute('cpp -C -dD '..args..' '..fin
                            ..' > '..fout..' 2>'..ferr)
            -- "-C":  keep comments (because of nesting)
            -- "-dD": repeat #define's (because of macros used as C functions)
    os.remove(fin)
    assert(ret == 0, assert(io.open(ferr)):read'*a')
    os.remove(ferr)

    -- remove blank lines of #define's (because of "-dD")
    _OPTS.source = assert(io.open(fout)):read'*a'
    _OPTS.source = string.gsub(_OPTS.source, '(#define[^\n]*)(\n)(\n)', '%1%3')
    os.remove(fout)
    --print(_OPTS.source)
end

patt:match(_OPTS.source..'\n')

-------------------------------------------------------------------------------

function DBG (...)
    local t = {}
    for i=1, select('#',...) do
        t[#t+1] = tostring( select(i,...) )
    end
    if #t == 0 then
        t = { [1]=debug.traceback() }
    end
    io.stderr:write(table.concat(t,'\t')..'\n')
end

function MAX (v1, v2)
    return (v1 > v2) and v1 or v2
end

function WRN (cond, ln, msg)
    ln = (_AST.isNode(ln) and ln.ln) or ln
    if not cond then
        DBG('WRN : '..ln[1]..' : line '..ln[2]..' : '..msg)
    end
    return cond
end
function ASR (cond, ln, msg)
    ln = (_AST.isNode(ln) and ln.ln) or ln
    if _RUNTESTS and (not cond) then
        return assert(false, 'ERR : '..ln[1]..' : line '..ln[2]..' : '..msg)
    else
        if not cond then
            DBG('ERR : '..ln[1]..' : line '..ln[2]..' : '..msg)
            os.exit(1)
        end
        return cond
    end
end

end

    
do
local P, C, V, Cc, Ct = m.P, m.C, m.V, m.Cc, m.Ct

local S = V'_SPACES'

local ERR_msg
local ERR_i
local LST_i

local I2TK

local f = function (s, i, tk)
    if tk == '' then
        tk = '<BOF>'
        LST_i = 1           -- restart parsing
        ERR_i = 0           -- ERR_i < 1st i
        ERR_msg = '?'
        I2TK = { [1]='<BOF>' }
    elseif i > LST_i then
        LST_i = i
        I2TK[i] = tk
    end
    return true
end
local K = function (patt)
    ERR_msg = '?'
    return #P(1) * m.Cmt(patt, f) * S
end
local CK = function (patt)
    ERR_msg = '?'
    return C(m.Cmt(patt, f))*S
end
local EK = function (tk)
    return K(tk) + m.Cmt(P'',
        function (_,i)
            if i > ERR_i then
                ERR_i = i
                ERR_msg = 'expected `'..tk.."´"
            end
            return false
        end) --* P(false)
end

local _V2NAME = {
    _Exp = 'expression',
    _Stmt = 'statement',
    Ext = 'event',
    Var = 'variable/event',
    ID_nat  = 'identifier',
    ID_var  = 'identifier',
    ID_int  = 'identifier',
    ID_ext  = 'identifier',
    ID_cls  = 'identifier',
    ID_type = 'type',
    _Dcl_var = 'declaration',
    _Dcl_int = 'declaration',
    __Dcl_nat  = 'declaration',
    _Dcl_nat   = 'declaration',
}
local EV = function (rule)
    return V(rule) + m.Cmt(P'',
        function (_,i)
            if i > ERR_i then
                ERR_i = i
                ERR_msg = 'expected ' .. _V2NAME[rule]
            end
            return false
        end) --* P(false)
end

local EM = function (msg)
    return m.Cmt(P'',
        function (_,i)
            if i > ERR_i then
                ERR_i = i
                ERR_msg = 'expected ' .. msg
                return false
            end
            return true
        end)
end

TYPES = P'void' + 'int'
      + 'u8' + 'u16' + 'u32' + 'u64'
      + 's8' + 's16' + 's32' + 's64'

KEYS = P'and'     + 'async'    + 'await'    + 'break'    + 'native'
     + 'constant' + 'continue' + 'safe'     + 'do'
     + 'else'     + 'else/if'  + 'emit'     + 'end'      + 'event'
     + 'every'    + 'finalize' + 'FOREVER'  + 'if'       + 'input'
     + 'loop'     + 'nohold'   + 'not'      + 'nothing'  + 'null'
     + 'or'       + 'output'   + 'par'      + 'par/and'  + 'par/or'
     + 'pause/if' + 'pure'     + 'return'   + 'sizeof'   + 'then'
     + 'until'    + 'var'      + 'with'
     + TYPES
-- ceu-orgs only
     + 'class'    + 'global'   + 'interface'
     + 'free'     + 'new'      + 'this'
     + 'spawn'
--
     --+ 'import'  --+ 'as'
-- export / version
     + 'thread'   + 'sync'

KEYS = KEYS * -m.R('09','__','az','AZ','\127\255')

local Alpha    = m.R'az' + '_' + m.R'AZ'
local Alphanum = Alpha + m.R'09'
local ALPHANUM = m.R'AZ' + '_' + m.R'09'
local alphanum = m.R'az' + '_' + m.R'09'

NUM = CK(m.R'09'^1) / tonumber

_GG = { [1] = CK'' * V'Stmts' * P(-1)-- + EM'expected EOF')

                -- "Ct" as a special case to avoid "too many captures" (HACK_1)
    , Stmts  = Ct (( V'_StmtS' * (EK';'*K';'^0) +
                     V'_StmtB' * (K';'^0)
                   )^0
                 * ( V'_LstStmt' * (EK';'*K';'^0) +
                     V'_LstStmtB' * (K';'^0)
                   )^-1 )
    , Block  = V'Stmts'

    , Do     = V'_Do'
    , _Do    = K'do' * V'Block' * K'end'

    , Nothing = K'nothing'

    , _StmtS = V'AwaitS'   + V'AwaitT'    + V'AwaitExt'  + V'AwaitInt'
             + V'EmitT'    + V'EmitExt'   + V'EmitInt'
             + V'_Dcl_nat'   + V'_Dcl_ext'
             + V'_Dcl_int' + V'_Dcl_var'
             + V'Dcl_det'
             + V'_Set'
             + V'Free'     + V'Spawn'
             + V'Nothing'
             + V'RawStmt'
             --+ V'Import'
             + V'CallStmt' -- last
             --+ EM'statement'-- (missing `_´?)'
             + EM'statement (usually a missing `var´ or C prefix `_´)'

    , _StmtB = V'Do'    + V'Host'
             + V'Async' + V'Thread' + V'Sync'
             + V'ParOr' + V'ParAnd'
             + V'If'    + V'Loop'   + V'_Every'  + V'_Iter'
             + V'Pause'
             + V'Dcl_ifc' + V'Dcl_cls'
             + V'Finalize'

    , _LstStmt  = V'_Return' + V'Break' + V'_Continue' + V'AwaitN'
    , _LstStmtB = V'ParEver' + V'_Continue'

    , _SetBlock  = V'Do' + V'ParEver' + V'If' + V'Loop' + V'_Every'
    , _SetThread = V'Thread'

    , New = K'new' * ('['*NUM*EK']'+Cc(false)) * V'ID_cls'
          * (EK'with' * V'Dcl_constr' * EK'end' + Cc(false))

    , _Set  = (V'_Exp' + V'VarList') * V'_Sets'
    , _Sets = (CK'='+CK':=') * (
                                    -- p1=awt, p2=false, p3=false
                Cc'_SetAwait'  * (V'AwaitS'+V'AwaitT'+V'AwaitExt'+V'AwaitInt')
                               * Cc(false) * Cc(false)
                                    -- p1=blk, p2=false, p3=false
              + Cc'SetBlock'   * V'_SetBlock'
                               * Cc(false) * Cc(false)
                                    -- p1=[list,blk]
              + Cc'_SetThread' * V'_SetThread'
                               * Cc(false) * Cc(false)
                                    -- p1=blk, p2=false, p3=false
              + Cc'SetExp'     * V'_Exp'
                               * Cc(false) * Cc(false)
                                    -- p1=New[max,cls,constr]
              + Cc'_SetNew'    * V'New'
                                    -- p1=Spawn[max,cls,constr]
              + Cc'_SetSpawn'  * V'Spawn'
              + EM'expression'
              )

    , Finalize = K'finalize' * (V'_Set'*EK';'*K';'^0 + Cc(false))
               * EK'with' * EV'Finally' * EK'end'
    , Finally  = V'Block'

    , Free  = K'free'  * V'_Exp'
    , Spawn = K'spawn' * ('['*NUM*EK']'+Cc(false))
            * EV'ID_cls'
            * (EK'with' * V'Dcl_constr' * EK'end' + Cc(false))

    , CallStmt = m.Cmt(V'_Exp',
                    function (s,i,...)
                        return (string.find(s, '%(.*%)')) and i, ...
                    end)

    --, Import = K'import' * ( C( (P(1)-m.S'\t\n\r ;')^1 )
                             --+ EM'module' ) *S

    , Sync    = K'sync'  * V'_Do'
    , Thread  = K'async' * K'thread'    * EV'VarList' * V'_Do'
    , Async   = K'async' * (-P'thread') * EV'VarList' * V'_Do'
    , VarList = ( K'(' * EV'Var' * (EK',' * EV'Var')^0 * EK')' )^-1

    , _Return = K'return' * EV'_Exp'

    , ParOr   = K'par/or' * EK'do' *
                    V'Block' * (EK'with' * V'Block')^1 *
                EK'end'
    , ParAnd  = K'par/and' * EK'do' *
                    V'Block' * (EK'with' * V'Block')^1 *
                EK'end'
    , ParEver = K'par' * EK'do' *
                    V'Block' * (EK'with' * V'Block')^1 *
                EK'end'

    , If      = K'if' * EV'_Exp' * EK'then' *
                    V'Block' *
                (K'else/if' * EV'_Exp' * EK'then' *
                    V'Block')^0 *
                (K'else' *
                    V'Block' + Cc(false)) *
                EK'end'-- - V'_Continue'

    , Break    = K'break'
    , _Continue = K'continue'

    , Loop    = K'loop' *
                    (V'ID_var' * (K','*EV'_Exp' + Cc(false)) +
                        Cc(false)*Cc(false)) *
                V'_Do'

    , _Iter   = K'loop' * V'ID_var' * K',' * V'ID_type'
              * V'_Do'

    , _Every  = K'every' * ( (EV'_Exp'+V'VarList') *(CK'='+CK':=')
                            + Cc(false)*Cc(false) )
              *  (V'WCLOCKK' + V'WCLOCKE' + EV'Ext' + EV'_Exp')
              * V'_Do'

    , _Exp    = V'_1'
    , _1      = V'_2'  * (CK'or'  * V'_2')^0
    , _2      = V'_3'  * (CK'and' * V'_3')^0
    , _3      = V'_4'  * ((CK'|'-'||') * V'_4')^0
    , _4      = V'_5'  * (CK'^' * V'_5')^0
    , _5      = V'_6'  * (CK'&' * V'_6')^0
    , _6      = V'_7'  * ((CK'!='+CK'==') * V'_7')^0
    , _7      = V'_8'  * ((CK'<='+CK'>='+(CK'<'-'<<')+(CK'>'-'>>')) * V'_8')^0
    , _8      = V'_9'  * ((CK'>>'+CK'<<') * V'_9')^0
    , _9      = V'_10' * ((CK'+'+CK'-') * V'_10')^0
    , _10     = V'_11' * ((CK'*'+(CK'/'-'//'-'/*')+CK'%') * V'_11')^0
    , _11     = ( Cc(true) * ( (CK'not'-'nothing') + CK'&' + CK'-' + CK'+' + CK'~' + CK'*'
                             + (K'('*V'ID_type'*K')') )
                )^0 * V'_12'
    , _12     = V'_13' *
                    (
                        K'(' * Cc'call' * V'ExpList' * EK')' *
                            ( K'finalize' * EK'with' * V'Finally' * EK'end'
                            + Cc(false)) +
                        K'[' * Cc'idx'  * V'_Exp'    * EK']' +
                        (CK':' + CK'.')
                            * (CK(Alpha * (Alphanum+'?')^0) /
                                function (id)
                                    return (string.gsub(id,'%?','_'))
                                end)
                    )^0
    , _13     = V'_Prim'
    , _Prim   = V'_Parens' + V'Var'   + V'Nat'   + V'SIZEOF'
              + V'NULL'    + V'CONST' + V'STRING'
              + V'Global' + V'This'   + V'RawExp'

    , ExpList = ( V'_Exp'*(K','*EV'_Exp')^0 )^-1

    , _Parens  = K'(' * EV'_Exp' * EK')'

    , SIZEOF = K'sizeof' * EK'(' * (V'ID_type' + V'_Exp') * EK')'
    , CONST = CK( #m.R'09' * (m.R'09'+m.S'xX'+m.R'AF'+m.R'af')^1 )
            + CK( "'" * (P(1)-"'")^0 * "'" )

    , NULL = CK'null'

    , WCLOCKK = #NUM *
                (NUM * K'h'   + Cc(0)) *
                (NUM * K'min' + Cc(0)) *
                (NUM * K's'   + Cc(0)) *
                (NUM * K'ms'  + Cc(0)) *
                (NUM * K'us'  + Cc(0)) *
                (NUM * EM'<h,min,s,ms,us>')^-1
    , WCLOCKE = K'(' * V'_Exp' * EK')' * (
                    CK'h' + CK'min' + CK's' + CK'ms' + CK'us'
                  + EM'<h,min,s,ms,us>'
              )

    , Pause    = K'pause/if' * EV'_Exp' * V'_Do'

    , AwaitN   = K'await' * K'FOREVER'

    , __until  = K'until' * EV'_Exp'
    , AwaitExt = K'await' * EV'Ext'  * (V'__until' + Cc(false))
    , AwaitInt = K'await' * EV'_Exp' * (V'__until' + Cc(false))
    , AwaitT   = K'await' * (V'WCLOCKK'+V'WCLOCKE')
                                     * (V'__until' + Cc(false))

    , __awaits = K'(' *
                    (V'WCLOCKK' + V'WCLOCKE' + V'Ext' + EV'_Exp')
                 * EK')'
    , AwaitS   = K'await' * V'__awaits' * (EK'or' * V'__awaits')^1
                                     * (V'__until' + Cc(false))

    , EmitT    = K'emit' * (V'WCLOCKK'+V'WCLOCKE')

    , EmitExt  = K'emit' * EV'Ext'  * V'__emit_ps'
    , EmitInt  = K'emit' * EV'_Exp' * V'__emit_ps'
    , __emit_ps = ( K'=>' * (V'_Exp' + K'(' * V'ExpList' * EK')')
                +   Cc(false) )

    , __ID     = V'ID_nat' + V'ID_ext' + V'Var'
    , Dcl_det  = K'safe' * EV'__ID' * EK'with' *
                     EV'__ID' * (K',' * EV'__ID')^0

    , __Dcl_nat = Cc'type' * V'ID_nat' * K'=' * NUM
                + Cc'func' * V'ID_nat' * '()' * Cc(false)
                + Cc'unk'  * V'ID_nat'        * Cc(false)

    , _Dcl_nat_ifc = K'native' * (CK'pure'+CK'constant'+CK'nohold'+Cc(false))
                        * EV'__Dcl_nat' * (K',' * EV'__Dcl_nat')^0
    , _Dcl_nat     = K'native' * (CK'pure'+CK'constant'+CK'nohold'+Cc(false))
                        * EV'__Dcl_nat' * (K',' * EV'__Dcl_nat')^0

    , _Dcl_ext = (CK'input'+CK'output') * (EV'ID_type'+EV'TupleType') *
                    EV'ID_ext' * (K','*EV'ID_ext')^0

    , _Dcl_int  = CK'event' * (EV'ID_type'+EV'TupleType') *
                    V'__Dcl_int' * (K','*V'__Dcl_int')^0
    , __Dcl_int = EV'ID_int' --* (V'_Sets' +
                             --   Cc(false)*Cc(false)*Cc(false))

    , _Dcl_var   = V'_Dcl_var_1' + V'_Dcl_var_2'

    -- w/o constructor
    , _Dcl_var_2 = CK'var'
                 * (EV'ID_type' + EV'ID_cls')
                 * (K'['*V'_Exp'*K']' + Cc(false))
                 * V'__Dcl_var' * (K','*V'__Dcl_var')^0

    -- w/  constructor
    , _Dcl_var_1 = CK'var'
                 * EV'ID_cls'
                 * (K'['*V'_Exp'*K']' + Cc(false))
                 * EV'ID_var'
                 * EK'with' * V'Dcl_constr' * EK'end'
    , Dcl_constr = V'Stmts'     -- TODO: Block?

    , __Dcl_var = EV'ID_var' * (V'_Sets' +
                                Cc(false)*Cc(false)*Cc(false)*Cc(false)*Cc(false))

    , _Dcl_imp = K'interface' * EV'ID_cls' * (K',' * EV'ID_cls')^0

    , BlockI = ( (V'_Dcl_int'+V'_Dcl_var'+
                   V'_Dcl_nat_ifc'+V'_Dcl_imp') * (EK';'*K';'^0)
               + V'Host'    -- method prototypes
               )^0
    , Dcl_ifc = K'interface' * Cc(true)
              * Cc(false)
              * EV'ID_cls'
              * EK'with' * V'BlockI' * EK'end'
    , Dcl_cls = K'class'     * Cc(false)
              * ('['*NUM*EK']' + Cc(false))
              * EV'ID_cls'
              * EK'with' * V'BlockI' * V'_Do'

    , Global  = K'global'
    , This    = K'this'

    , Ext     = V'ID_ext'
    , Var     = V'ID_var'
    , Nat     = V'ID_nat'

    , ID_cls  = -KEYS * CK(m.R'AZ'*Alphanum^0)
    , ID_ext  = -KEYS * CK(m.R'AZ'*ALPHANUM^0)
    , ID_var  = -KEYS * CK(m.R'az'*(Alphanum+'?')^0)
                    / function(id) return (string.gsub(id,'%?','_')) end
    , ID_int  = V'ID_var'
    , ID_nat  = CK(  P'_' *Alphanum^0)
    , ID_type = (CK(TYPES)+V'ID_nat'+V'ID_cls') * C(K'*'^0) /
                  function (id, star)
                    return (string.gsub(id..star,' ',''))
                  end

    , TupleType = K'(' * EV'ID_type' * (EK','*EV'ID_type')^0 * EK')'

    , STRING = CK( CK'"' * (P(1)-'"'-'\n')^0 * EK'"' )

    , Host    = K'native' * (#EK'do')*'do' * --m.S' \n\t'^0 *
                    ( C(V'_C') + C((P(1)-(m.S'\t\n\r '*'end'*P';'^0*'\n'))^0) )
                *S* EK'end'

    , RawStmt = K'{' * C((P(1)-'}')^0) * EK'}'
    , RawExp  = K'{' * C((P(1)-'}')^0) * EK'}'

    --, _C = '/******/' * (P(1)-'/******/')^0 * '/******/'
    , _C      = m.Cg(V'_CSEP','mark') *
                    (P(1)-V'_CEND')^0 *
                V'_CEND'
    , _CSEP = '/***' * (1-P'***/')^0 * '***/'
    , _CEND = m.Cmt(C(V'_CSEP') * m.Cb'mark',
                    function (s,i,a,b) return a == b end)

    , _SPACES = (  m.S'\t\n\r '
                + ('//' * (P(1)-'\n')^0 * P'\n'^-1)
                + ('#'  * (P(1)-'\n')^0 * P'\n'^-1) -- TODO: set of #'s/only after spaces
                + V'_COMM'
                )^0

    , _COMM    = '/' * m.Cg(P'*'^1,'comm') * (P(1)-V'_COMMCMP')^0 * V'_COMMCL'
                    / function () end
    , _COMMCL  = C(P'*'^1) * '/'
    , _COMMCMP = m.Cmt(V'_COMMCL' * m.Cb'comm',
                    function (s,i,a,b) return a == b end)
}

function err ()
    local x = (ERR_i<LST_i) and 'before' or 'after'
--DBG(LST_i, ERR_i, ERR_msg, _I2L[LST_i], I2TK[LST_i])
    local file, line = unpack(_LINES.i2l[LST_i])
    return 'ERR : '..file..
              ' : line '..line..
              ' : '..x..' `'..(I2TK[LST_i] or '?').."´"..
              ' : '..ERR_msg
end

if _RUNTESTS then
    assert(m.P(_GG):match(_OPTS.source), err())
else
    if not m.P(_GG):match(_OPTS.source) then     -- TODO: match only in ast.lua?
        DBG(err())
        os.exit(1)
    end
end

end

    
do
-- points to the main file body
_MAIN = nil     -- should be only one "Main"

local TOP   = {}    -- holds all clss/exts/nats
local TOP_i = 1     -- next top
local C;

local modules = {}

_AST = {
    root = nil,
}

local MT    = {}
local STACK = {}

function _AST.isNode (node)
    return (getmetatable(node) == MT) and node.tag
end

function _AST.isChild (n1, n2)
    return n1 == n2
        or n2.__par and _AST.isChild(n1, n2.__par)
end

local _N = 0
function _AST.node (tag)
    return function (ln, ...)
        local me = setmetatable({ ... }, MT)
        me.n = _N
        _N = _N + 1
        me.ln  = ln
        me.tag = tag
        return me
    end
end
local node = _AST.node

function _AST.pred_async (me)
    local tag = me.tag
    return tag=='Async' or tag=='Thread'
end
function _AST.pred_par (me)
    local tag = me.tag
    return tag=='ParOr' or tag=='ParAnd' or tag=='ParEver'
end
--[[
function _AST.pred_prio (me)
    local tag = me.tag
    return tag=='SetBlock' or tag=='ParOr' or tag=='Loop'
end
]]
function _AST.pred_true (me) return true end

function _AST.iter (pred, inc)
    if pred == nil then
        pred = _AST.pred_true
    elseif type(pred) == 'string' then
        local tag = pred
        pred = function(me) return me.tag==tag end
    end
    local from = (inc and 1) or #STACK
    local to   = (inc and #STACK) or 1
    local step = (inc and 1) or -1
    local i = from
    return function ()
        for j=i, to, step do
            local stmt = STACK[j]
            if pred(stmt) then
                i = j+step
                return stmt
            end
        end
    end
end

function _AST.copy (node, ln)
    local ret = setmetatable({}, MT)
    for k, v in pairs(node) do
        if _AST.isNode(v) then
            ret[k] = _AST.copy(v, ln)
            ret[k].ln = ln or ret[k].ln
        else
            ret[k] = v
        end
    end
    return ret
end

function _AST.dump (me, spc)
    spc = spc or 0
    local ks = ''
--[[
    for k, v in pairs(me) do
        if type(k)~='number' then
            v = string.gsub(string.sub(tostring(v),1,8),'\n','\\n')
            ks = ks.. k..'='..v..','
        end
    end
]]
    --local t=0; for _ in pairs(me.aw.t) do t=t+1 end
    --ks = 'n='..(me.aw.n or '?')..',t='..t..',ever='..(me.aw.forever_ and 1 or 0)
    --ks = table.concat(me.trails,'-')
--
--[[
    local f = function(v)
                return type(v)=='table'
                            and (type(v[1])=='table' and v[1].id or v[1])
                    or tostring(v)
              end
    local t = {}
    for k in pairs(me.ana.pre) do t[#t+1]=f(k) end
    ks = '['..table.concat(t,',')..']'
    local t = {}
    for k in pairs(me.ana.pos) do t[#t+1]=f(k) end
    ks = ks..'['..table.concat(t,',')..']'
]]
--
    --ks = me.ns.trails..' / '..tostring(me.needs_clr)
    DBG(string.rep(' ',spc)..me.tag..
        ' (ln='..me.ln[2]..' n='..me.n..' d='..(me.depth or 0)..') '..ks)
    for i, sub in ipairs(me) do
        if _AST.isNode(sub) then
            _AST.dump(sub, spc+2)
        else
            DBG(string.rep(' ',spc+2) .. '['..tostring(sub)..']')
        end
    end
end

local function FF (F, str)
    local f = F[str]
    if type(f) == 'string' then
        return FF(F, f)
    end
    assert(f==nil or type(f)=='function')
    return f
end

local function visit_aux (me, F)
--DBG(me.tag, me, F)
    local pre, mid, pos = FF(F,me.tag..'_pre'), FF(F,me.tag), FF(F,me.tag..'_pos')
    local bef, aft = FF(F,me.tag..'_bef'), FF(F,me.tag..'_aft')

    if F.Node_pre then me=(F.Node_pre(me) or me) end
    if pre then me=(pre(me) or me) end

    me.__par = STACK[#STACK]
    STACK[#STACK+1] = me

    for i, sub in ipairs(me) do
        if _AST.isNode(sub) then
            sub.depth = me.depth + 1
            ASR(sub.depth < 0xFF, sub, 'max depth of 0xFF')
            if bef then bef(me, sub, i) end
            me[i] = visit_aux(sub, F)
            if aft then aft(me, sub, i) end
        end
    end

    if mid then me=(mid(me) or me) end
    if F.Node then me=(F.Node(me) or me) end
    STACK[#STACK] = nil
    if pos then me=(pos(me) or me) end
    if F.Node_pos then me=(F.Node_pos(me) or me) end

    return me
end
_AST.visit_aux = visit_aux

function _AST.visit (F, node)
    assert(_AST)
    --STACK = {}
    _AST.root.depth = 0
    return visit_aux(node or _AST.root, F)
end

function _AST.SetAwaitUntil (ln, awt, op,to)
    local ret

    -- set await
    if op then
        local val = node('SetVal')(ln)
        val.from = awt
        ret = node('Stmts')(ln,
                awt,
                node('SetExp')(ln, op, val, to))
        awt.setto = true
    else
        ret = awt
    end

    -- await until
    local cnd = awt[#awt]
    awt[#awt] = false
    if cnd then
        ret = _AST.node('Loop')(ln,
                    _AST.node('Stmts')(ln,
                        ret,
                        _AST.node('If')(ln, cnd,
                            _AST.node('Break')(ln),
                            _AST.node('Nothing')(ln))))
        ret.isAwaitUntil = true
    end

    return ret
end

C = {
    [1] = function (ln, spc, ...) -- spc=CK''
        C.Dcl_cls(ln, false, false,
                      'Main',
                      node('Stmts')(ln),
                      node('Stmts')(ln,...))
        _MAIN = TOP[#TOP]
        _AST.root = node('Root')(ln, unpack(TOP))
        return _AST.root
    end,

    Stmts = function (ln, me)   -- (HACK_1)
        return _AST.node('Stmts')(ln, unpack(me))
    end,

    BlockI  = node('BlockI'),
    Do      = node('Do'),
    Nothing = node('Nothing'),
    Block   = node('Block'),
    Host    = node('Host'),

    RawStmt = node('RawStmt'),
    RawExp  = node('RawExp'),

    Finalize = node('Finalize'),
    Finally  = node('Finally'),

    _Return = node('_Return'),

--[[
    Import = function (ln, url)
        local ret = node('Stmts')(ln,   -- #HOLE to fill w/ top-level stmts
                        node('Import')(ln))
        table.insert(TOP, TOP_i, node('_Import')(ln,url,ret))
        TOP_i = TOP_i + 1
        return ret
    end,
]]

    Sync = node('Sync'),
    Thread = function (ln, ...)
        local thr = node('Thread')(ln,...)
        local raw = node('RawStmt')(ln, nil)    -- see code.lua
              raw.thread = thr
        return node('Stmts')(ln,
                    node('Finalize')(ln,
                        false,
                        node('Finally')(ln,
                            node('Block')(ln,
                                node('Stmts')(ln,raw)))),
                    thr)
    end,

    Async = node('Async'),
    VarList = function (ln, ...)
        local t = { ... }
        for i, var in ipairs(t) do
            t[i] = var
        end
        return node('VarList')(ln, unpack(t))
    end,

    ParEver = node('ParEver'),
    ParOr   = node('ParOr'),
    ParAnd  = node('ParAnd'),

    If = function (ln, ...)
        local t = { ... }
        local _else = t[#t] or node('Nothing')(ln)
        for i=#t-1, 1, -2 do
            local c, b = t[i-1], t[i]
            _else = node('If')(ln, c, b, _else)
        end
        return _else
    end,

    _Continue = node('_Continue'),
    Break = node('Break'),

    Loop  = function (ln, _i, _j, blk)
        if not _i then
            local n = node('Loop')(ln, blk)
            n.blk = blk     -- continue
            return n
        end

        local i = function() return node('Var')(ln, _i) end
        local dcl_i = node('Dcl_var')(ln, 'var', 'int', false, _i)
        dcl_i.read_only = true
        local set_i = node('SetExp')(ln, '=', node('CONST')(ln,'0'), i())
        set_i.read_only = true  -- accept this write
        local nxt_i = node('SetExp')(ln, '=',
                        node('Op2_+')(ln, '+', i(), node('CONST')(ln,'1')),
                        i())
        nxt_i.read_only = true  -- accept this write

        if not _j then
            local n = node('Loop')(ln,
                        node('Stmts')(ln,
                            blk,
                            nxt_i))
            n.blk = blk     -- _Continue needs this
            return node('Block')(ln,
                    node('Stmts')(ln, dcl_i, set_i, n))
        end

        local dcl_j, set_j, j

        if _j.tag == 'CONST' then
            ASR(tonumber(_j[1]) > 0, ln,
                'constant should not be `0´')
            j = function () return _j end
            dcl_j = node('Nothing')(ln)
            set_j = node('Nothing')(ln)
        else
            local j_name = '_j'..blk.n
            j = function() return node('Var')(ln, j_name) end
            dcl_j = node('Dcl_var')(ln, 'var', 'int', false, j_name)
            set_j = node('SetExp')(ln, '=', _j, j())
        end

        local cmp = node('Op2_>=')(ln, '>=', i(), j())

        local loop = node('Loop')(ln,
                        node('Stmts')(ln,
                            node('If')(ln, cmp,
                                node('Break')(ln),
                                node('Nothing')(ln)),
                            blk,
                            nxt_i))
        loop.blk = blk      -- continue
        loop.isBounded = (_j.tag=='CONST' and 'const') or 'var'

        return node('Block')(ln,
                node('Stmts')(ln,
                    dcl_i, set_i,
                    dcl_j, set_j,
                    loop))
    end,

    _Every = function (ln, to, op, evt, blk)
        local tag
        if evt.tag == 'Ext' then
            tag = 'AwaitExt'
        elseif evt.tag=='WCLOCKK' or evt.tag=='WCLOCKE' then
            tag = 'AwaitT'
        else
            tag = 'AwaitInt'
        end

        local awt = node(tag)(ln, evt, false)
        awt.isEvery = true

        local stmts = awt

        if to then
            -- TODO: join this code w/ _Set
            if to.tag == 'VarList' then
                local tup = '_tup_'.._N
                _N = _N + 1

                local t = {
                    _AST.copy(evt), -- find out 'TP' before traversing tup
                    node('Dcl_var')(ln, 'var', 'TP*', false, tup),
                    _AST.SetAwaitUntil(ln, awt, '=', node('Var')(ln,tup)),
                                        -- assignment to struct must be '='
                }
                t[2].__ref = t[1] -- TP* is changed on env.lua

                for i, v in ipairs(to) do
                    t[#t+1] = node('SetExp')(ln, op,
                                node('Op2_.')(ln, '.',
                                    node('Op1_*')(ln, '*',
                                        node('Var')(ln, tup)),
                                    '_'..i),
                                v)
                    t[#t].fromAwait = awt

                    -- TODO: workaround that avoids checking := for fields
                    t[#t].dont_check_nofin = true
                end
                stmts = node('Stmts')(ln, unpack(t))

            else
                stmts = _AST.SetAwaitUntil(ln, awt, op, to)
            end
        end

        local ret = node('Loop')(ln,
                        node('Stmts')(ln,
                            stmts,
                            blk))
        ret.isEvery = true
        return ret
    end,

    _Iter = function (ln, id2, tp2, blk)
        local id1 = '_i'.._N ; _N=_N+1
        local tp1 = '_tceu_org*'

        local var1 = function() return node('Var')(ln, id1) end
        local var2 = function() return node('Var')(ln, id2) end

        local dcl1 = node('Dcl_var')(ln, 'var', tp1, false, id1)
        local dcl2 = node('Dcl_var')(ln, 'var', tp2, false, id2)
        dcl2.read_only = true

        local ini1 = node('SetExp')(ln, ':=',
                                        node('RawExp')(ln,nil), -- see val.lua
                                        var1())
        ini1[2].iter_ini = true
        local ini2 = node('SetExp')(ln, '=',
                        node('Op1_cast')(ln, tp2, var1()),
                        var2())
        ini2.read_only = true   -- accept this write

        local nxt1 = node('SetExp')(ln, ':=',
                                        node('RawExp')(ln,nil), -- see val.lua
                                        var1())
        nxt1[2].iter_nxt = nxt1[3]   -- var
        local nxt2 = node('SetExp')(ln, '=',
                        node('Op1_cast')(ln, tp2, var1()),
                        var2())
        nxt2.read_only = true   -- accept this write

        local loop = node('Loop')(ln,
                        node('Stmts')(ln,
                            node('If')(ln,
                                node('Op2_==')(ln, '==',
                                                   var1(),
                                                   node('NULL')(ln)),
                                node('Break')(ln),
                                node('Nothing')(ln)),
                            node('If')(ln,
                                node('Op2_==')(ln, '==',
                                                   var2(),
                                                   node('NULL')(ln)),
                                node('Nothing')(ln),
                                blk),
                            nxt1,nxt2))
        loop.blk = blk      -- continue
        loop.isBounded = true

        return node('Block')(ln, node('Stmts')(ln, dcl1,dcl2, ini1,ini2, loop))
    end,

    Pause = function (ln, evt, blk)
        local cur_id  = '_cur_'..blk.n
        local cur_dcl = node('Dcl_var')(ln, 'var', 'u8', false, cur_id)

        local PSE = node('Pause')(ln, blk)
        PSE.dcl = cur_dcl

        local on  = node('PauseX')(ln, 1)
            on.blk  = PSE
        local off = node('PauseX')(ln, 0)
            off.blk = PSE

        return
            node('Block')(ln,
                node('Stmts')(ln,
                    cur_dcl,    -- Dcl_var(cur_id)
                    node('SetExp')(ln, '=',
                        node('CONST')(ln, '0'),
                        node('Var')(ln, cur_id)),
                    node('ParOr')(ln,
                        node('Loop')(ln,
                            node('Stmts')(ln,
                                _AST.SetAwaitUntil(ln,
                                    node('AwaitInt')(ln, evt, false),
                                    '=',
                                    node('Var')(ln, cur_id)),
                                node('If')(ln,
                                    node('Var')(ln, cur_id),
                                    on,
                                    off))),
                        PSE)))
    end,
--[=[
        var u8 psed? = 0;
        par/or do
            loop do
                psed? = await <evt>;
                if psed? then
                    PauseOff()
                else
                    PauseOn()
                end
            end
        with
            pause/if (cur) do
                <blk>
            end
        end
]=]

    AwaitExt = node('AwaitExt'),
    AwaitInt = node('AwaitInt'),
    AwaitN   = node('AwaitN'),
    AwaitT   = node('AwaitT'),
    AwaitS   = node('AwaitS'),

    _Dcl_ext = function (ln, dir, tp, ...)
        for _, v in ipairs{...} do
            table.insert(TOP, TOP_i,
                node('Dcl_ext')(ln, dir, tp, v))
            TOP_i = TOP_i + 1
        end
    end,

    _Dcl_nat_ifc = function (ln, mod, ...)
        local ret = {}
        local t = { ... }
        for i=1, #t, 3 do   -- pure/const/false, type/func/var, id, len
            ret[#ret+1] = node('Dcl_nat')(ln, mod, t[i], t[i+1], t[i+2])
        end
        return unpack(ret)
    end,
    _Dcl_nat = function (ln, ...)
        local ret = { C._Dcl_nat_ifc(ln, ...) }
        for _, t in ipairs(ret) do
            table.insert(TOP, TOP_i, t)
            TOP_i = TOP_i + 1
        end
    end,

    Dcl_det = node('Dcl_det'),

    _Dcl_var_2 = function (ln, pre, tp, dim, ...)
        local ret = {}
        local t = { ... }
        -- id, op, tag, exp, constr
        for i=1, #t, 6 do
            ret[#ret+1] = node('Dcl_var')(ln, pre, tp, dim, t[i])
            if t[i+1] then
                ret[#ret+1] = C._Set(ln,
                                node('Var')(ln,t[i]),   -- var
                                t[i+1],                 -- op
                                t[i+2],                 -- tag
                                t[i+3],                 -- exp    (p1)
                                t[i+4],                 -- max    (p2)
                                t[i+5])                 -- constr (p3)
            end
        end
        return unpack(ret)
    end,
    _Dcl_var_1 = function (ln, pre, tp, dim, id, constr)
        return node('Dcl_var')(ln, pre, tp, dim, id, constr)
    end,
    Dcl_constr = node('Dcl_constr'),

    -- TODO: unify with _Dcl_var
    _Dcl_int = function (ln, pre, tp, ...)
        local ret = {}
        local t = { ... }
        for i=1, #t do
            ret[#ret+1] = node('Dcl_int')(ln, pre, tp, false, t[i])
        end
        return unpack(ret)
    end,

    _Dcl_imp = function (ln, ...)
        local ret = {}
        local t = { ... }
        for _, ifc in ipairs(t) do
            ret[#ret+1] = node('Dcl_imp')(ln, ifc)
        end
        return unpack(ret)
    end,

    Dcl_ifc = function (...) return C.Dcl_cls(...) end,
    Dcl_cls = function (ln, is_ifc, n, id, blk_ifc, blk_body)
        local blk = node('Block')(ln, node('Stmts')(ln,blk_ifc,blk_body))
        local this = blk
        if id == 'Main' then
            blk = node('Block')(ln,
                    node('Stmts')(ln,
                        node('Dcl_var')(ln, 'var', 'int', false, '_ret'),
                        node('SetBlock')(ln, blk,
                            node('Var')(ln,'_ret'))))
        end

        local cls = node('Dcl_cls')(ln, is_ifc, n, id, blk)
        cls.blk_ifc  = this  -- top-most block for `this´
        cls.blk_body = blk_body
        table.insert(TOP, TOP_i, cls)
        TOP_i = TOP_i + 1
    end,

    Global = node('Global'),
    This   = node('This'),
    Free   = node('Free'),

    New   = node('New'),
    Spawn = node('Spawn'),

    _Set = function (ln, to, op, tag, p1, p2, p3)
        if to.tag == 'VarList' then
            ASR(tag=='_SetAwait', ln,
                'invalid attribution (`await´ expected)')

            local tup = '_tup_'.._N
            _N = _N + 1

            local t = {
                _AST.copy(p1[1]),   -- find out 'TP' before traversing tup
                node('Dcl_var')(ln, 'var', 'TP*', false, tup),
                _AST.SetAwaitUntil(ln, p1, '=', node('Var')(ln,tup)),
                                        -- assignment to struct must be '='
            }
            t[2].__ref = t[1] -- TP* is changed on env.lua

            for i, v in ipairs(to) do
                t[#t+1] = node('SetExp')(ln, op,
                            node('Op2_.')(ln, '.',
                                node('Op1_*')(ln, '*',
                                    node('Var')(ln, tup)),
                                '_'..i),
                            v)
                t[#t].fromAwait = p1    -- p1 is an AwaitX

                -- TODO: workaround that avoids checking := for fields
                t[#t].dont_check_nofin = true
            end
            return node('Stmts')(ln, unpack(t))

        elseif tag == 'SetExp' then
            return node(tag)(ln, op, p1, to)

        elseif tag == '_SetAwait' then
            return _AST.SetAwaitUntil(ln, p1, op, to)

        elseif tag == 'SetBlock' then
            return node(tag)(ln, p1, to)

        elseif tag == '_SetThread' then
            local thr = p1[2]

            local val = node('SetVal')(ln)
            val.from = thr
            thr.setto = true

            p1[2] = node('Stmts')(ln, thr, node('SetExp')(ln,op,val,to))
            return p1

        else -- '_SetNew', '_SetSpawn'
            local val = node('SetVal')(ln)
            val.from = p1
            p1.setto = true
            return node('Stmts')(ln, p1, node('SetExp')(ln,op,val,to))
        end
    end,

    EmitT = node('EmitT'),
    EmitInt = function (ln, int, ps)
        return C.EmitExt(ln, int, ps, 'EmitInt')
    end,
    EmitExt = function (ln, ext, ps, tag)
        tag = tag or 'EmitExt'

        -- no exp: emit e
        if not ps then
            return node(tag)(ln, ext, false)

        -- single: emit e => a
        elseif ps.tag~='ExpList' then
            return node(tag)(ln, ext, ps)

        -- multiple: emit e => (a,b)
        else
            local tup = '_tup_'.._N
            _N = _N + 1
            local t = {
                _AST.copy(ext),  -- find out 'TP' before traversing tup
                node('Dcl_var')(ln, 'var', 'TP', false, tup)
            }
            t[2].__ref = t[1]    -- TP is changed on env.lua

            for i, p in ipairs(ps) do
                t[#t+1] = node('SetExp')(ln, '=',
                            p,
                            node('Op2_.')(ln, '.', node('Var')(ln, tup),
                                '_'..i))
            end

            t[#t+1] = node(tag)(ln, ext,
                        node('Op1_&')(ln, '&',
                            node('Var')(ln, tup)))

            return node('Stmts')(ln, unpack(t))
        end
    end,

    CallStmt = node('CallStmt'),

    _Exp = function (ln, ...)
        local v1, v2, v3, v4 = ...
        local ret
        if not v2 then          -- single value
            ret = v1
        elseif v1==true then    -- unary expression
            -- v1=true, v2=op, v3=exp
            local op = v2
            if not (op=='not' or op=='&' or op=='-'
                 or op=='+' or op=='~' or op=='*') then
                op = 'cast'
            end
            ret = node('Op1_'..op)(ln, v2,
                                    C._Exp(ln, select(3,...)))
        else                    -- binary expression
            -- v1=e1, v2=op, v3=e2, v4=?
            if v2 == ':' then
                ret = C._Exp(ln,
                    node('Op2_.')(ln, '.', node('Op1_*')(ln,'*',v1), v3),
                    select(4,...)
                )
            elseif v2 == 'call' then
                ret = C._Exp(ln,
                    node('Op2_'..v2)(ln, v2, v1, v3, v4),
                    select(5,...)
                )
            else
                ret = C._Exp(ln,
                    node('Op2_'..v2)(ln, v2, v1, v3),
                    select(4,...)
                )
            end
        end
        ret.isExp = true
        return ret
    end,
    ExpList  = node('ExpList'),

    TupleType = node('TupleType'),

    Var      = node('Var'),
    Ext      = node('Ext'),
    Nat      = node('Nat'),
    SIZEOF   = node('SIZEOF'),
    CONST    = node('CONST'),
    WCLOCKK  = node('WCLOCKK'),
    WCLOCKE  = node('WCLOCKE'),
    STRING   = node('STRING'),
    NULL     = node('NULL'),
}

local function i2l (p)
    return _LINES.i2l[p]
end

for rule, f in pairs(C) do
    _GG[rule] = (m.Cp()/i2l) * _GG[rule] / f
end

for i=1, 12 do
    local tag = '_'..i
    _GG[tag] = (m.Cp()/i2l) * _GG[tag] / C._Exp
end

_GG = m.P(_GG):match(_OPTS.source)

end

    
do
F = {
-- IMPORT: ignore top-level stmts & Global
--[[
    Node = function (me)
        -- ignore top-level stmts, except "Host"
        local inc = _AST.iter'Import'()  -- inc[1] = Stmts #HOLE
        if inc then
            if me.tag == 'Host' then
                inc.__par[#inc.__par+1] = me
            end
            return _AST.node('Nothing')(me.ln,false)
        end
    end,
    Dcl_cls = function (me)
        -- ignore Global if url~=main
        if me[3]=='Global' and me.ln[1]~=_AST.root.ln[1] then
            return _AST.node('Nothing')(me.ln)
        end
    end,
]]
---

-- AWAIT: await x until y (not child from SetAwait)
    AwaitT = function (me)
        if me.setto then
            return      -- already handled by SetAwait
        end
        local ret = _AST.SetAwaitUntil(me.ln, me)
        return ret
    end,
    AwaitExt = 'AwaitT',
    AwaitInt = 'AwaitT',
    AwaitS   = 'AwaitT',
---

-- FINALIZE: Await+Set => Await+FIN(Set)
    Finalize = function (me)
        if (not me[1]) or (me[1].tag ~= 'Stmts') then
            return      -- normal finalize
        end

        ASR(me[1][1].tag == 'AwaitInt', me,
            'invalid finalize (multiple scopes)')

        -- invert fin <=> await
        local ret = me[1]   -- return stmts
        me[1] = ret[2]      -- await => fin
        ret[2] = me         -- fin => stmts[2]
        return ret
    end,
---

--?
    SetBlock_pre = function (me)
        me.blk = _AST.iter'Block'()
    end,
    _Return = function (me)
        local set = _AST.iter'SetBlock'()
        local fr = unpack(me)
        --local to = _AST.node('Var')(me.ln,set[2][1])
        local to = _AST.copy(set[2])
        to.blk = set.blk
        to.ret = true

        local blk = _AST.node('Stmts')(me.ln)
        blk[#blk+1] = _AST.node('SetExp')(me.ln, '=', fr, to, set[3])

        blk[#blk+1] = _AST.node('Return')(me.ln)
        return blk
    end,

    _Continue = function (me)
        local _if  = _AST.iter('If')()
        local loop = _AST.iter('Loop')()
        ASR(_if and loop, me,
            'invalid `continue´')

        loop.hasContinue = true
        _if.hasContinue = true
        ASR( _if[3].tag=='Nothing'     and   -- no else
            me.depth  == _if.depth+3   and   -- If->Block->Stmts->Continue
             _if.depth == loop.blk.depth+2 , -- Block->Stmts->If
            me, 'invalid `continue´')
        return _AST.node('Nothing')(me.ln)
    end,
    Loop = function (me)
        if not me.hasContinue then
            return
        end

        -- start from last to first continue
        local stmts = me.blk[1]
        local N = #stmts
        local has = true
        while has do
            has = false
            for i=N, 1, -1 do
                local n = stmts[i]
                if n.hasContinue then
                    has = true
                    N = i-1
                    local _else = _AST.node('Stmts')(n.ln)
                    n[3] = _else
                    for j=i+1, #stmts do
                        _else[#_else+1] = stmts[j]
                        stmts[j] = nil
                    end
                end
            end
        end
    end,
}

_AST.visit(F)

end

    
do
_OPTS.tp_word = assert(tonumber(_OPTS.tp_word),
    'missing `--tp-word´ parameter')

_ENV = {
    clss  = {},     -- { [1]=cls, ... [cls]=0 }
    clss_ifc = {},
    clss_cls = {},

    calls = {},     -- { _printf=true, _myf=true, ... }

    -- f=fields, e=events
    ifcs  = {
        flds = {}, -- {[1]='A',[2]='B',A=0,B=1,...}
        evts = {}, -- ...
    },

    exts = {
        --[1]=ext1,         [ext1.id]=ext1.
        --[N-1]={_ASYNC},   [id]={},
        --[N]={_WCLOCK},    [id]={},
    },

    -- TODO: move to _TP
    c = {
        void = 0,

        u8=1, u16=2, u32=4, u64=8,
        s8=1, s16=2, s32=4, s64=8,

        word     = _OPTS.tp_word,
        int      = _OPTS.tp_word,
        pointer  = _OPTS.tp_word,

        tceu_ncls = true,    -- env.lua
        tceu_nlbl = true,    -- labels.lua
    },
    dets  = {},

    max_evt = 0,    -- max # of internal events (exts+1 start from it)
}

for k, v in pairs(_ENV.c) do
    if v == true then
        _ENV.c[k] = { tag='type', id=k, len=nil }
    else
        _ENV.c[k] = { tag='type', id=k, len=v }
    end
end

function CLS ()
    return _AST.iter'Dcl_cls'()
end

function var2ifc (var)
    return table.concat({
        var.id,
        var.tp,
        tostring(var.pre),
        tostring(var.arr),
    }, '$')
end

function _ENV.ifc_vs_cls (ifc, cls)
    -- check if they have been checked
    ifc.matches = ifc.matches or {}
    cls.matches = cls.matches or {}
    if ifc.matches[cls] ~= nil then
        return ifc.matches[cls]
    end

    -- check if they match
    for _, v1 in ipairs(ifc.blk_ifc.vars) do
        v2 = cls.blk_ifc.vars[v1.id]
        if v2 then
            v2.ifc_id = v2.ifc_id or var2ifc(v2)
        end
        if (not v2) or (v1.ifc_id~=v2.ifc_id) then
            ifc.matches[cls] = false
            return false
        end
    end

    -- yes, they match
    ifc.matches[cls] = true
    cls.matches[ifc] = true
    return true
end

-- unique numbers for vars and events
local _N = 0
local _E = 1    -- 0=NONE

function newtype (tp)
    local raw = _TP.noptr(tp)

    local c = _ENV.c[raw]
    if c or string.sub(raw,1,1)~='_' then
        return  -- already declared or not external type
    end

    _ENV.c[raw] = { tag='type', id=raw, len=nil, mod=nil }
end

function newvar (me, blk, pre, tp, arr, id)
    for stmt in _AST.iter() do
        if _AST.pred_async(stmt) then
            break   -- search until Async/Thread
        elseif stmt.tag == 'Block' then
            for _, var in ipairs(stmt.vars) do
                --ASR(var.id~=id or var.blk~=blk, me,
                    --'variable/event "'..var.id..
                    --'" is already declared at --line '..var.ln)
                if (var.id == id) and
                        -- ifc vs ifc ok (constant def)
                    ( (    blk ~= CLS().blk_ifc) or
                      (var.blk ~= CLS().blk_ifc) ) then
                    WRN(false, me,
                        'declaration of "'..id..'" hides the one at line '
                            ..var.ln[2])
                    ASR( (blk ~= CLS().blk_ifc) and
                         (blk ~= CLS().blk_body), me,
                        'cannot hide at top-level block' )
                end
            end
        end
    end

    local isEvt = (pre == 'event')
    local tp_raw = _TP.noptr(tp)
    local c = _ENV.c[tp_raw]

    ASR(_ENV.clss[tp_raw] or c, me,
            'undeclared type `'..tp_raw..'´')
    ASR(not _ENV.clss_ifc[tp], me,
        'cannot instantiate an interface')
    ASR(_TP.deref(tp) or (not c) or (tp=='void' and isEvt) or c.len~=0, me,
        'cannot instantiate type "'..tp..'"')
    --ASR((not arr) or arr>0, me, 'invalid array dimension')

    tp = (arr and tp..'*') or tp

    local tp_ = _TP.deref(tp)
    local cls = _ENV.clss[tp] or (arr and tp_ and _ENV.clss[tp_])
    if cls then
        ASR(cls~=_AST.iter'Dcl_cls'() and isEvt==false, me,
                'invalid declaration')
    end

    local inTop = (blk == CLS().blk_ifc) or (blk == CLS().blk_body)
    if inTop and blk.vars[id] then
        return blk.vars[id]
    end

    local var = {
        ln    = me.ln,
        id    = id,
        cls   = cls,
        tp    = tp,
        blk   = blk,
        pre   = pre,
        inTop = inTop,  -- var is in top-level of class (accessible from C)
        isEvt = isEvt,
        evt_idx = isEvt and _E,
        isTmp = false,
        arr   = arr,
        --val   = '0',     -- TODO: workaround: dummy value for interfaces
        n     = _N,
    }

    _N = _N + 1
    if isEvt then
        _E = _E + 1
    end

    blk.vars[#blk.vars+1] = var
    blk.vars[id] = var -- TODO: last/first/error?
    -- TODO: warning in C (hides)

    return var
end

function _ENV.getvar (id, blk)
    local blk = blk or _AST.iter('Block')()
    while blk do
        if _AST.pred_async(blk) then
            return nil                  -- async boundary (stop search)
        elseif blk.tag == 'Block' then
            for i=#blk.vars, 1, -1 do   -- n..1 (hidden vars)
                local var = blk.vars[i]
                if var.id == id then
                    return var
                end
            end
        end
        blk = blk.__par
    end
    return nil
end

-- identifiers for ID_c / ID_ext (allow to be defined after annotations)
-- variables for Var
function det2id (v)
    if type(v) == 'string' then
        return v
    else
        return v.var
    end
end

F = {
    Root_pre = function (me)
        -- TODO: NONE=0
        -- TODO: if _PROPS.* then ... end

        local evt = {id='_STK', pre='input'}
        _ENV.exts[#_ENV.exts+1] = evt
        _ENV.exts[evt.id] = evt

        -- TODO: shared with _INIT?
        local evt = {id='_ORG', pre='input'}
        _ENV.exts[#_ENV.exts+1] = evt
        _ENV.exts[evt.id] = evt

        local evt = {id='_ORG_PSED', pre='input'}
        _ENV.exts[#_ENV.exts+1] = evt
        _ENV.exts[evt.id] = evt

        local evt = {id='_INIT', pre='input'}
        _ENV.exts[#_ENV.exts+1] = evt
        _ENV.exts[evt.id] = evt

        local evt = {id='_CLEAR', pre='input'}
        _ENV.exts[#_ENV.exts+1] = evt
        _ENV.exts[evt.id] = evt

        local evt = {id='_WCLOCK', pre='input'}
        _ENV.exts[#_ENV.exts+1] = evt
        _ENV.exts[evt.id] = evt

        local evt = {id='_ASYNC', pre='input'}
        _ENV.exts[#_ENV.exts+1] = evt
        _ENV.exts[evt.id] = evt

        local evt = {id='_THREAD', pre='input'}
        _ENV.exts[#_ENV.exts+1] = evt
        _ENV.exts[evt.id] = evt
    end,

    Root = function (me)
        _ENV.c.tceu_ncls.len = _TP.n2bytes(#_ENV.clss_cls)
        ASR(_ENV.max_evt+#_ENV.exts <= 255, me, 'too many events')

        -- matches all ifc vs cls
        for _, ifc in ipairs(_ENV.clss_ifc) do
            for _, cls in ipairs(_ENV.clss_cls) do
                _ENV.ifc_vs_cls(ifc, cls)
            end
        end
        local glb = _ENV.clss.Global
        if glb then
            ASR(glb.is_ifc and glb.matches[_ENV.clss.Main], me,
                'interface "Global" must be implemented by class "Main"')
        end
    end,

    Block_pre = function (me)
        me.vars = {}
        local async = _AST.iter()()
        if _AST.pred_async(async) then
            local vars, blk = unpack(async)
            if vars then
                for _, n in ipairs(vars) do -- create new variables for params
                    local var = n.var
                    ASR(not var.arr, vars, 'invalid argument')
                    n.new = newvar(vars, blk, 'var', var.tp, nil, var.id)
                end
            end
        end
    end,

    Dcl_cls_pre = function (me)
        local ifc, max, id, blk = unpack(me)
        me.is_ifc = ifc
        me.max    = max
        me.id     = id
        me.c      = {}      -- holds all "native _f()"
        ASR(not _ENV.clss[id], me,
                'interface/class "'..id..'" is already declared')

        -- restart variables/events counting
        _N = 0
        _E = 1  -- 0=NONE

        _ENV.clss[id] = me
        _ENV.clss[#_ENV.clss+1] = me

        if me.is_ifc then
            me.n = #_ENV.clss_ifc   -- TODO: n=>?
            _ENV.clss_ifc[id] = me
            _ENV.clss_ifc[#_ENV.clss_ifc+1] = me
        else
            me.n = #_ENV.clss_cls   -- TODO: remove Main?   -- TODO: n=>?
            _ENV.clss_cls[id] = me
            _ENV.clss_cls[#_ENV.clss_cls+1] = me
        end
    end,
    Dcl_cls = function (me)
        _ENV.max_evt = MAX(_ENV.max_evt, _E)

        -- all identifiers in all interfaces get a unique N
        if me.is_ifc then
            for _, var in pairs(me.blk_ifc.vars) do
                var.ifc_id = var.ifc_id or var2ifc(var)
                if not _ENV.ifcs[var.ifc_id] then
                    if var.isEvt then
                        _ENV.ifcs.evts[var.ifc_id] = #_ENV.ifcs.evts
                        _ENV.ifcs.evts[#_ENV.ifcs.evts+1] = var.ifc_id
                    else
                        _ENV.ifcs.flds[var.ifc_id] = #_ENV.ifcs.flds
                        _ENV.ifcs.flds[#_ENV.ifcs.flds+1] = var.ifc_id
                    end
                end
            end
        end
    end,

    Dcl_det = function (me)                 -- TODO: verify in _ENV.c
        local id1 = det2id(me[1])
        local t1 = _ENV.dets[id1] or {}
        _ENV.dets[id1] = t1
        for i=2, #me do
            local id2 = det2id(me[i])
            local t2 = _ENV.dets[id2] or {}
            _ENV.dets[id2] = t2
            t1[id2] = true
            t2[id1] = true
        end
    end,

    Global = function (me)
        ASR(_ENV.clss.Global and _ENV.clss.Global.is_ifc, me,
            'interface "Global" is not defined')
        me.tp   = 'Global*'
        me.lval = false
        me.ref  = me
        me.fst  = me
        me.blk  = true --_MAIN.blk
    end,

    This = function (me)
        local cls

        local constr = _AST.iter'Dcl_constr'()
        if constr then
            cls = constr.cls
        else
            cls = CLS()
            ASR(cls ~= _MAIN, me, 'invalid access')
        end
        ASR(cls, me, 'undeclared class')

        me.tp   = cls.id
        me.lval = false
        me.ref  = me
        me.fst  = me
        me.blk  = cls.blk_ifc
    end,

    Free = function (me)
        local exp = unpack(me)
        local _tp = _TP.deref(exp.tp)
        ASR(_tp and _ENV.clss[_tp], me, 'invalid `free´')
    end,

    TupleType = function (me)
        local tp = '_tceu'
        for i, v in ipairs(me) do
            local tp_raw = _TP.noptr(v)
            local c = _ENV.c[tp_raw]
            --ASR(c or _ENV.clss[tp_raw], me, 'undeclared type `'..tp_raw..'´')
            me[i] = v
            tp = tp .. '__'.._TP.c(v)
        end

        tp = string.gsub(tp, '*', '_')  -- TODO: '_' is not reliable
        _ENV.c[tp] = { tag='type', id=tp, tuple=me, len=nil }
        return tp
    end,

    Dcl_ext = function (me)
        local dir, tp, id = unpack(me)
        newtype(tp)
        if _ENV.exts[id] then
            WRN(false, me, 'event "'..id..'" is already declared')
            return
        end
        ASR(tp=='void' or tp=='int' or _TP.deref(tp) or _TP.isTuple(tp), me,
                'invalid event type')

        if _TP.isTuple(tp) then
            tp = tp..'*'
        end

        me.evt = {
            ln    = me.ln,
            id    = id,
            tp    = tp,
            pre   = dir,
            isEvt = true,
        }
        _ENV.exts[#_ENV.exts+1] = me.evt
        _ENV.exts[id] = me.evt
    end,

    Dcl_var_pre = function (me)
        -- changes TP from ast.lua
        if me.__ref then
            local ref = me.__ref
            ASR(ref.evt, me,
                'event "'..(ref.var and ref.var.id or '?')..'" is not declared')
            if me[2] == 'TP' then
                me[2] = _TP.deref(ref.evt.tp)
            else    --  'TP*'
                me[2] = ref.evt.tp
            end
        end
    end,

    Dcl_int = 'Dcl_var',
    Dcl_var = function (me)
        local pre, tp, arr, id, constr = unpack(me)
        newtype(tp)
        if pre == 'event' then
            ASR(tp=='void' or tp=='int' or _TP.deref(tp) or _TP.isTuple(tp), me,
                    'invalid event type')
            if _TP.isTuple(tp) then
                tp = tp..'*'
            end
        end
        me.var = newvar(me, _AST.iter'Block'(), pre, tp, arr, id)
        me.var.read_only = me.read_only

        if constr then
            constr.blk = me.var.blk
        end
    end,

    Dcl_imp = function (me)
        local id = unpack(me)
        local ifc = ASR(_ENV.clss[id], me,
                        'interface "'..id..'" is not declared')
        ASR(ifc.is_ifc, me, '`'..id..'´ is not an interface')

        -- copy vars
        for _, var in ipairs(ifc.blk_ifc.vars) do
            local tp = (var.arr and _TP.deref(var.tp)) or var.tp
            newvar(me, _AST.iter'Block'(), var.pre, tp, var.arr, var.id)
            CLS().c[var.id] = ifc.c[var.id] -- also copy C properties
        end
    end,

    Ext = function (me)
        local id = unpack(me)
        me.evt = ASR(_ENV.exts[id], me,
                    'event "'..id..'" is not declared')
    end,

    Var = function (me)
        local id = unpack(me)
        local blk = me.blk or _AST.iter('Block')()
        local var = _ENV.getvar(id, blk)
        ASR(var, me, 'variable/event "'..id..'" is not declared')
        me.var  = var
        me.tp   = var.tp
        me.lval = (not var.arr) and (not var.cls) and var
        me.ref  = me
        me.fst  = var
        if var.isEvt then
            me.evt = var
        end
    end,

    Dcl_nat = function (me)
        local mod, tag, id, len = unpack(me)
        --assert(not len) -- TODO: not using len anymore

        if _AST.iter'BlockI'() then
            ASR(tag == 'func', me, 'only methods are allowed')
            -- native _f()  =>  CEU_T__f  (must be defined manually)
            local cls = CLS()
            local tp = '___typeof__(CEU_'..cls.id..'_'..id..')'
            _ENV.c[tp] = { tag='type', id=tp }
            newvar(me, _AST.iter'Block'(), 'var', tp..'*', false, id)
            cls.c[id] = { tag=tag, id=id, mod=mod }
        else
            _ENV.c[id] = { tag=tag, id=id, len=len, mod=mod }
        end
    end,

    Dcl_pure = function (me)
        _ENV.pures[me[1]] = true
    end,

    AwaitS = function (me)
        local wclock
        for _, awt in ipairs(me) do
            if awt.isExp then
                F.AwaitInt(me, awt)
            elseif awt.tag~='Ext' then
                ASR(not wclock, me,
                    'invalid await: multiple timers')
                wclock = true
            end
        end
        error'me.fst'
        --me.fst = ?
    end,
    AwaitInt = function (me, exp)
        local exp = exp or unpack(me)
        local var = exp.var
        ASR(var and var.isEvt, me,
                'event "'..(var and var.id or '?')..'" is not declared')
        me.fst = exp.fst
    end,
    AwaitExt = function (me)
        me.fst = 'global'
    end,

    EmitInt = function (me)
        local int, ps = unpack(me)
        local var = int.var
        ASR(var and var.isEvt, me,
                'event "'..(var and var.id or '?')..'" is not declared')
        ASR(int.tp=='void' or  (ps and _TP.contains(int.var.tp,ps.tp,true)), me,
                'invalid emit')
    end,

    EmitExt = function (me)
        local ext, ps = unpack(me)
        if ext.evt.pre == 'input' then
            return
        end
        ASR(ext.evt.pre == 'output', me, 'invalid input `emit´')
        me.tp = 'int'

        if ps then
            ASR(_TP.contains(ext.evt.tp,ps.tp,true), me,
                "non-matching types on `emit´")
        else
            ASR(ext.evt.tp=='void', me,
                "missing parameters on `emit´")
        end
    end,

    --------------------------------------------------------------------------

    SetExp = function (me)
        local _, fr, to = unpack(me)
        to = to or _AST.iter'SetBlock'()[1]
        ASR(to.lval and _TP.contains(to.tp,fr.tp,true), me,
                'invalid attribution ('..to.tp..' vs '..fr.tp..')')
        ASR(me.read_only or (not to.lval.read_only), me,
                'read-only variable')
        ASR(not CLS().is_ifc, me, 'invalid attribution')

        if fr.from and (fr.from.tag == 'New') then
            -- a = new T
            fr.from.blk = to.ref.var.blk   -- to = me.__par[3]

            -- refuses (x.ptr = new T;)
            ASR( _AST.isChild(CLS(),to.ref.var.blk), me,
                    'invalid attribution (no scope)' )
        end
    end,

--[[
-- TODO: remove?
-- await ... until?
    SetAwait = function (me)
        local _, awt, to = unpack(me)
        ASR(to.lval, me, 'invalid attribution')

        if awt.tag == 'Loop' then
            awt = awt[1][1]         -- await ... until
        end
        me.awt = awt                -- will need me.awt.val
    end,
]]

    SetVal = function (me)
        if me.from.tag == 'AwaitT' then
            me.tp = 's32'               -- late
        elseif me.from.tag == 'AwaitS' then
            me.tp = 'int'
        elseif me.from.tag=='AwaitInt' or me.from.tag=='AwaitExt' then
            me.tp = me.from[1].evt.tp   -- evt tp
        elseif me.from.tag == 'New' then
            me.tp = me.from[2]..'*'     -- class id
        elseif me.from.tag == 'Spawn' then
            me.tp = 'int'               -- 0/1
        elseif me.from.tag == 'Thread' then
            me.tp = 'int'               -- 0/1
        else
            error'unexpected error'
        end
        me.fst = me.from.fst
    end,

    Free = function (me)
        local exp = unpack(me)
        local id = ASR(_TP.deref(exp.tp), me, 'invalid `free´')
        me.cls = ASR( _ENV.clss[id], me,
                        'class "'..id..'" is not declared')
    end,

    New = function (me)
        local max, id, constr = unpack(me)

        me.cls = ASR(_ENV.clss[id], me,
                        'class "'..id..'" is not declared')
        ASR(not me.cls.is_ifc, me, 'cannot instantiate an interface')
        me.fst = 'global'   -- "a = new T"      ("a" will determine)
        me.fst = 'global'   -- "a = spawn T"    (constant value 0/1)

--[[
        _AST.visit(F, me.__par[2][3])
        F.Spawn(me, me.__par[2][3].ref.var.blk)    -- also sets me.cls

-- TODO: remove (SetExp should do)
        ASR(to.lval and _TP.contains(to.tp,me.cls.id..'*')
                         -- refuses (x.ptr = new T;)
                     and _AST.isChild(CLS(),to.ref.var.blk),
                me, 'invalid attribution ('..to.tp..' vs '..me.cls.id..'*)')
]]
    end,

    Spawn = function (me, blk)
        local max, id, constr = unpack(me)
        F.New(me)
        me.blk = ASR(_AST.iter'Do'(), me,
                        '`spawn´ requires enclosing `do ... end´')
        me.blk = me.blk[1]
    end,

    Dcl_constr_pre = function (me)
        local spw = _AST.iter'Spawn'()
        local new = _AST.iter'New'()
        local dcl = _AST.iter'Dcl_var'()

        -- type check for this.* inside constructor
        if spw then
            me.cls = _ENV.clss[ spw[2] ]   -- checked on Spawn
        elseif new then
            me.cls = _ENV.clss[ new[2] ]   -- checked on SetExp
        elseif dcl then
            me.cls = _ENV.clss[ dcl[2] ]   -- checked on Dcl_var
        end
        --assert(me.cls)
    end,

    CallStmt = function (me)
        local call = unpack(me)
        ASR(call.tag == 'Op2_call', me, 'invalid statement')
    end,

    --------------------------------------------------------------------------

    Op2_call = function (me)
        local _, f, _, _ = unpack(me)
        me.tp  = '_'
        me.fst = '_'
        local id
        if f.tag == 'Nat' then
            id   = f[1]
            me.c = _ENV.c[id]
        elseif f.tag == 'Op2_.' then
            id   = f.id
            if f.org then   -- t._f()
                me.c = assert(_ENV.clss[f.org.tp]).c[f.id]
            else            -- _x._f()
                me.c = f.c
            end
        else
            id = '$anon'
            me.c = { tag='func', id=id, mod=nil }
        end

        ASR((not _OPTS.c_calls) or _OPTS.c_calls[id], me,
                'native calls are disabled')

        if not me.c then
            me.c = { tag='func', id=id, mod=nil }
            _ENV.c[id] = me.c
        end
        ASR(me.c and me.c.tag=='func', me,
            'native function "'..id..'" is not declared')

        _ENV.calls[id] = true
    end,

    Op2_idx = function (me)
        local _, arr, idx = unpack(me)
        local tp = ASR(_TP.deref(arr.tp,true), me, 'cannot index a non array')
        ASR(tp and _TP.isNumeric(idx.tp,true), me, 'invalid array index')
        me.tp = tp
        me.lval = (not _ENV.clss[tp]) and arr
        me.ref  = arr.ref
        me.fst  = arr.fst
    end,

    Op2_int_int = function (me)
        local op, e1, e2 = unpack(me)
        me.tp  = 'int'
        ASR(_TP.isNumeric(e1.tp,true) and _TP.isNumeric(e2.tp,true), me,
                'invalid operands to binary "'..op..'"')
    end,
    ['Op2_-']  = 'Op2_int_int',
    ['Op2_+']  = 'Op2_int_int',
    ['Op2_%']  = 'Op2_int_int',
    ['Op2_*']  = 'Op2_int_int',
    ['Op2_/']  = 'Op2_int_int',
    ['Op2_|']  = 'Op2_int_int',
    ['Op2_&']  = 'Op2_int_int',
    ['Op2_<<'] = 'Op2_int_int',
    ['Op2_>>'] = 'Op2_int_int',
    ['Op2_^']  = 'Op2_int_int',

    Op1_int = function (me)
        local op, e1 = unpack(me)
        me.tp  = 'int'
        ASR(_TP.isNumeric(e1.tp,true), me,
                'invalid operand to unary "'..op..'"')
    end,
    ['Op1_~']  = 'Op1_int',
    ['Op1_-']  = 'Op1_int',

    Op2_same = function (me)
        local op, e1, e2 = unpack(me)
        me.tp  = 'int'
        ASR(_TP.max(e1.tp,e2.tp,true), me,
                'invalid operands to binary "'..op..'"')
    end,
    ['Op2_=='] = 'Op2_same',
    ['Op2_!='] = 'Op2_same',
    ['Op2_>='] = 'Op2_same',
    ['Op2_<='] = 'Op2_same',
    ['Op2_>']  = 'Op2_same',
    ['Op2_<']  = 'Op2_same',

    Op2_any = function (me)
        me.tp  = 'int'
    end,
    ['Op2_or']  = 'Op2_any',
    ['Op2_and'] = 'Op2_any',
    ['Op1_not'] = 'Op2_any',

    ['Op1_*'] = function (me)
        local op, e1 = unpack(me)
        me.tp   = _TP.deref(e1.tp, true)
        me.lval = e1.lval and e1
        me.ref  = e1.ref
        me.fst  = e1.fst
        ASR(me.tp, me, 'invalid operand to unary "*"')
    end,

    ['Op1_&'] = function (me)
        local op, e1 = unpack(me)
        ASR(_ENV.clss[e1.tp] or e1.lval, me, 'invalid operand to unary "&"')
        me.tp   = e1.tp..'*'
        me.lval = false
        me.ref  = e1.ref
        me.fst  = e1.fst
    end,

    ['Op2_.'] = function (me)
        local op, e1, id = unpack(me)
        local cls = _ENV.clss[e1.tp]
        me.id = id
        if cls then
            me.org = e1

            local var = ASR(cls.blk_ifc.vars[id], me,
                        'variable/event "'..id..'" is not declared')
            me[3] = _AST.node('Var')(me.ln, '$'..id)
            me[3].var = var

            me.org  = e1
            me.var  = var
            me.tp   = var.tp
            me.lval = (not var.arr) and (not var.cls) and var
            me.ref  = me[3]
            if var.isEvt then
                me.evt    = me.var
                me[3].evt = var
            end
        else
            ASR(_TP.ext(e1.tp,true), me, 'not a struct')
            local tup = _TP.isTuple(e1.tp)
            if tup then
                local n = tonumber(string.match(id,'(%d+)'))
                me.tp = tup[n] or 'void'
            else
                me.tp = '_'
            end
            me.lval = e1.lval
            me.ref  = e1.ref
        end
        me.fst = e1.fst
    end,

    Op1_cast = function (me)
        local tp, exp = unpack(me)
        me.tp   = tp
        me.lval = exp.lval
        me.ref  = exp.ref
        me.fst  = exp.fst
    end,

    Nat = function (me)
        local id = unpack(me)
        local c = _ENV.c[id]
        ASR((not c) or c.tag~='type', me,
            'native variable/function "'..id..'" is not declared')
        me.tp   = '_'
        me.lval = me
        me.ref  = me
        me.fst  = '_'
        me.c    = c
    end,
    RawExp = function (me)
        me.tp   = '_'
        me.lval = me
        me.ref  = me
        me.fst  = '_'
    end,

    WCLOCKK = function (me)
        me.tp   = 'int'
        me.lval = false
        me.fst  = 'global'
    end,
    WCLOCKE = 'WCLOCKK',

    SIZEOF = function (me)
        me.tp   = 'int'
        me.lval = false
        me.fst  = 'global'
    end,

    STRING = function (me)
        me.tp   = '_char*'
        me.lval = false
        me.fst  = 'global'
    end,
    CONST = function (me)
        local v = unpack(me)
        me.tp   = 'int'
        me.lval = false
        me.fst  = 'global'
        ASR(string.sub(v,1,1)=="'" or tonumber(v), me, 'malformed number')
    end,
    NULL = function (me)
        me.tp   = 'null*'
        me.lval = false
        me.fst  = 'global'
    end,
}

_AST.visit(F)

end

    
do
F = {
    SetExp = function (me)
        local op, fr, to = unpack(me)
        to = to or _AST.iter'SetBlock'()[1]

        local req = false

        if me.fromAwait then
            -- (a,b) = await X;
            ----
            -- var t* p;        -- wrong scope (p is a local)
            -- p = await X;     -- right scope (where X is defined)
            -- a = p:_1;
            -- b = p:_2;
            fr = me.fromAwait
        end

        if _TP.deref(to.tp) then
            local to_blk = (to.fst=='_' and _AST.root) or to.fst.blk

            -- var T t with
            --  this.x = y;     -- blk of this? (same as block of t)
            -- end;
            -- spawn T with
            --  this.x = y;     -- blk of this? (same as parent spawn/new)
            -- end
            local constr = _AST.iter'Dcl_constr'()
            if constr then
                local dcl = _AST.iter'Dcl_var'()
                if dcl then
                    to_blk = dcl.var.blk
                else
                    to_blk = constr.__par.blk
                end
            end

            assert(fr.fst)
            -- '_' is in the global scope
            if fr.fst~='global' and fr.fst~='_' then
                local fr_blk = fr.fst.blk
                if fr_blk then
                    local to_depth = (to_blk==true and 0) or to_blk.depth
                    local fr_depth = (fr_blk==true and 0) or fr_blk.depth

                    -- int a; pa=&a;    -- `a´ termination must consider `pa´
                    req = fr_depth > to_depth and (
                            to_blk == true or                 -- `pa´ global
                            fr_depth > CLS().blk_body.depth   -- `a´ not top-level
                    )
                end
                req = req and fr_blk
            else
                -- int* pa = _fopen();  -- `pa´ termination must consider ret
                req = (fr.tag=='Op2_call' and fr.c.mod~='pure')
                        or fr.tag == 'RawExp'
                req = req and to_blk
            end
        end

        if _AST.iter'Thread'() then
            req = false     -- impossible to run finalizers on threads
        end

        if req then
            ASR((op==':=') or me.fin, me,
                    'attribution requires `finalize´')
        else
            -- TODO: workaround that avoids checking := for fields
            if not me.dont_check_nofin then
                ASR((op=='=') and (not me.fin), me,
                        'attribution does not require `finalize´')
            end
        end

        if me.fin and me.fin.active then
            req.fins = req.fins or {}
            table.insert(req.fins, 1, me.fin)
        end
    end,

    Finalize_pre = function (me, set, fin)
        if not fin then
            set, fin = unpack(me)
        end
        assert(fin[1].tag == 'Block')
        assert(fin[1][1].tag == 'Stmts')
        fin.active = fin[1] and fin[1][1] and
                        (#fin[1][1]>1 or
                         fin[1][1][1] and fin[1][1][1].tag~='Nothing')

        if _AST.iter'Dcl_constr'() then
            ASR(not fin.active, me,
                    'only empty finalizers inside constructors')
        end

        if set then
            set.fin = fin                   -- let call/set handle
        elseif fin.active then
            local blk = _AST.iter'Block'()
            blk.fins = blk.fins or {}
            table.insert(blk.fins, 1, fin)  -- force finalize for this blk
        end
    end,

    Op2_call_pre = function (me)
        local _, f, exps, fin = unpack(me)
        if fin then
            F.Finalize_pre(me, me, fin)
        end
    end,
    Op2_call = function (me)
        local _, f, exps, fin = unpack(me)

        local req = false

        if not (me.c and (me.c.mod=='pure' or me.c.mod=='nohold')) then
            if f.org and string.sub(me.c.id,1,1)=='_' then
                --exps = { f.org, unpack(exps) }  -- only native
                -- avoids this.f(), where f is a pointer to func
                -- vs this._f()
            end
            for _, exp in ipairs(exps) do
                -- int* pa; _f(pa); -- `pa´ termination must consider `_f´
                local r = exp.fst and (
                             _TP.deref(exp.tp)
                          or (_TP.ext(exp.tp) and (not exp.c or
                                                   exp.c.mod~='constant'))
                          or _ENV.clss[_TP.noptr(exp.tp)])
                r = r and ((exp.fst=='_' and _AST.root) or exp.fst.blk)
                WRN( (not r) or (not req) or (r==req),
                        me, 'invalid call (multiple scopes)')
                req = req or r
            end
        end

        if _AST.iter'Thread'() then
            req = false     -- impossible to run finalizers on threads
        end

        ASR((not req) or fin, me,
            'call to "'..me.c.id..'" requires `finalize´')
        ASR((not fin) or req, me, 'invalid `finalize´')

        if fin and fin.active then
            req.fins = req.fins or {}
            table.insert(req.fins, 1, fin)
        end
    end,
}

_AST.visit(F)

end

    
do
_TIGHT = false

function OR_all (me, t)
    t = t or me
    me.tl_awaits  = false
    me.tl_returns = false
    me.tl_blocks  = false
    for _, sub in ipairs(t) do
        if _AST.isNode(sub) then
            me.tl_awaits  = me.tl_awaits  or sub.tl_awaits
            me.tl_returns = me.tl_returns or sub.tl_returns
            me.tl_blocks  = me.tl_blocks  or sub.tl_blocks
        end
    end
end

function AND_all (me, t)
    t = t or me
    me.tl_awaits  = true
    me.tl_returns = true
    me.tl_blocks  = true
    for _, sub in ipairs(t) do
        if _AST.isNode(sub) then
            me.tl_awaits  = me.tl_awaits  and sub.tl_awaits
            me.tl_returns = me.tl_returns and sub.tl_returns
            me.tl_blocks  = me.tl_blocks  and sub.tl_blocks
        end
    end
end

function SAME (me, sub)
    me.tl_awaits  = sub.tl_awaits
    me.tl_returns = sub.tl_returns
    me.tl_blocks  = sub.tl_blocks
end

F = {
    Node_pre = function (me)
        me.tl_awaits  = false
        me.tl_returns = false
        me.tl_blocks  = false
    end,
    Node = function (me)
        if not F[me.tag] then
            OR_all(me)
        end
    end,

    Stmts   = OR_all,

    ParEver = OR_all,
    ParAnd  = OR_all,
    ParOr   = AND_all,

    If = function (me)
        local c, t, f = unpack(me)
        AND_all(me, {t,f})
    end,

    Break = function (me)
        me.tl_blocks = true
    end,
    Loop = function (me)
        local body = unpack(me)
        SAME(me, body)
        local isTight = (not _AST.iter(_AST.pred_async)())
                            and (not body.tl_blocks)
                            and (not me.isBounded)
        WRN(not isTight, me, 'tight loop')
        _TIGHT = _TIGHT or isTight
        me.tl_blocks = (body.tl_awaits or body.tl_returns) and me.isBounded~='var'
    end,

    SetBlock = function (me)
        local blk,_ = unpack(me)
        SAME(me, blk)
        me.tl_returns = false
    end,
    Return = function (me)
        me.tl_returns = true
        me.tl_blocks  = true
    end,

    Thread = 'Async',
    Async = function (me)
        local _,body = unpack(me)
        SAME(me, body)
        me.tl_awaits = true
        me.tl_blocks = true
    end,

    AwaitExt = function (me)
        me.tl_awaits = true
        me.tl_blocks = true
    end,
    AwaitInt = 'AwaitExt',
    AwaitT   = 'AwaitExt',
    AwaitN   = 'AwaitExt',
    AwaitS   = 'AwaitExt',
}

_AST.visit(F)

end

    --dofile 'awaits.lua'
    
do
_PROPS = {
    has_exts    = false,
    has_wclocks = false,
    has_ints    = false,
    has_asyncs  = false,
    has_threads = false,
    has_orgs    = false,
    has_news    = false,
    has_news_pool   = false,
    has_news_malloc = false,
    has_ifcs    = false,
    has_clear   = false,
    has_pses    = false,
}

local NO_fin = {
    Finalize=true, Finally=true,
    Host=true, Return=true, Async=true, Thread=true,
    ParEver=true, ParOr=true, ParAnd=true,
    AwaitS=true, AwaitExt=true, AwaitInt=true, AwaitN=true, AwaitT=true,
    EmitInt=true,
    Pause=true,
}

local NO_async = {
    Async=true, Thread=true,
    ParEver=true, ParOr=true, ParAnd=true,
    AwaitS=true, AwaitExt=true, AwaitInt=true, AwaitN=true, AwaitT=true,
    EmitInt=true,
    Pause=true,
    Return=true,
}

local NO_constr = {
    --Finalize=true, Finally=true,
    Return=true, Async=true, Thread=true,
    ParEver=true, ParOr=true, ParAnd=true,
    AwaitS=true, AwaitExt=true, AwaitInt=true, AwaitN=true, AwaitT=true,
    EmitInt=true,
    Pause=true,
}

-- Loop, SetBlock may need clear
-- if break/return are in parallel w/ something
--                  or inside block that needs_clr
function NEEDS_CLR (top)
    for n in _AST.iter() do
        if n.tag == top.tag then
            break
        elseif n.tag == 'ParEver' or
               n.tag == 'ParAnd'  or
               n.tag == 'ParOr'   or
               n.tag == 'Block' and n.needs_clr then
            _PROPS.has_clear = true
            top.needs_clr = true
            break
        end
    end
end

function HAS_FINS ()
    for n in _AST.iter() do
        if n.tag == 'Block'    or
           n.tag == 'ParOr'    or
           n.tag == 'Loop'     or
           n.tag == 'SetBlock' then
            n.needs_clr_fin = true
        end
    end
end

F = {
    Node_pos = function (me)
        if NO_fin[me.tag] then
            ASR(not _AST.iter'Finally'(), me,
                'not permitted inside `finalize´')
        end
        if NO_async[me.tag] then
            ASR(not _AST.iter(_AST.pred_async)(), me,
                    'not permitted inside `async´')
        end
        if NO_constr[me.tag] then
            ASR(not _AST.iter'Dcl_constr'(), me,
                    'not permitted inside a constructor')
        end
    end,

    Block_pre = function (me)       -- _pre: break/return depends on it
        if me.fins then
            me.needs_clr = true
            me.needs_clr_fin = true
            _PROPS.has_clear = true
        end

        for _, var in ipairs(me.vars) do
            if var.cls then
                me.needs_clr = true
                _PROPS.has_clear = true
                break
            end
        end

        if me.needs_clr then
            HAS_FINS()  -- TODO (-ROM): could avoid ors w/o fins
        end
    end,
    Free = function (me)
        _PROPS.has_news = true
        _PROPS.has_clear = true
    end,
    New = function (me)
        local max,_,_ = unpack(me)

        _PROPS.has_news = true
        if max or me.cls.max then
            _PROPS.has_news_pool = true

            if max then
                local blk = me.blk
                blk.pools = blk.pools or {}
                blk.pools[me] = max
            end
        else
            _PROPS.has_news_malloc = true
        end

        _PROPS.has_clear = true
        me.blk.needs_clr = true
        ASR(not _AST.iter'BlockI'(), me,
                'not permitted inside an interface')
    end,
    Spawn = 'New',

    ParOr = function (me)
        me.needs_clr = true
        _PROPS.has_clear = true
    end,

    Loop_pre = function (me)
        me.brks = {}
        me.noAwtsEmts = true
    end,
    Break = function (me)
        local loop = _AST.iter'Loop'()
        ASR(loop, me, 'break without loop')
        loop.brks[me] = true
        loop.has_break = true

        NEEDS_CLR(loop)

        local fin = _AST.iter'Finally'()
        ASR(not fin or fin.depth<loop.depth, me,
                'not permitted inside `finalize´')
        -- TODO: same for return

        local async = _AST.iter(_AST.pred_async)()
        if async then
            local loop = _AST.iter'Loop'()
            ASR(loop.depth>async.depth, me, '`break´ without loop')
        end
    end,

    SetBlock_pre = function (me)
        me.rets = {}
        ASR(not _AST.iter'BlockI'(), me,
                'not permitted inside an interface')
    end,
    Return = function (me)
        local blk = _AST.iter'SetBlock'()
        blk.rets[me] = true
        blk.has_return = true

        NEEDS_CLR(blk)
    end,

    Dcl_cls = function (me)
        _PROPS.has_orgs = _PROPS.has_orgs or (me.id~='Main')
        if me.is_ifc then
            _PROPS.has_ifcs = true
        end
    end,

    Dcl_ext = function (me)
        _PROPS.has_exts = true
    end,

    Dcl_var = function (me)
        if me.var.cls then
            if _AST.iter'BlockI'() then
                CLS().has_pre = true   -- code for pre (before constr)
            end
        end
    end,

    Async = function (me)
        _PROPS.has_asyncs = true
    end,
    Thread = function (me)
        _PROPS.has_threads = true
    end,
    Sync = function (me)
        ASR(_AST.iter'Thread'(), me,'not permitted outside `thread´')
    end,

    Pause = function (me)
        _PROPS.has_pses = true
    end,

    _loop1 = function (me)
        for loop in _AST.iter'Loop' do
            if loop.isEvery then
                ASR(me.isEvery, me,
                    '`every´ cannot contain `await´')
            end
        end
    end,
    _loop2 = function (me)
        for loop in _AST.iter'Loop' do
            loop.noAwtsEmts = false     -- TODO: move to tmps.lua
        end
    end,

    AwaitT = function (me)
        _PROPS.has_wclocks = true
        F._loop1(me)
        F._loop2(me)
    end,
    AwaitInt = function (me)
        _PROPS.has_ints = true
        F._loop1(me)
        F._loop2(me)
    end,
    AwaitExt = function (me)
        F._loop1(me)
        F._loop2(me)
    end,
    AwaitN = function (me)
        F._loop1(me)
        F._loop2(me)
    end,
    AwaitS = function (me)
        for _, awt in ipairs(me) do
            if awt.isExp then
                F.AwaitInt(me)
            elseif awt.tag=='Ext' then
                F.AwaitExt(me)
            else
                F.AwaitT(me)
            end
        end
    end,

    EmitInt = function (me)
        _PROPS.has_ints = true
        F._loop2(me)
    end,

    EmitExt = function (me)
        if _AST.iter(_AST.pred_async)() then
            ASR(me[1].evt.pre=='input',  me, 'not permitted inside `async´')
        else
            ASR(me[1].evt.pre=='output', me, 'not permitted outside `async´')
        end
    end,
    EmitT = function (me)
        ASR(_AST.iter(_AST.pred_async)(), me,'not permitted outside `async´')
    end,

    SetExp = function (me)
        local _, _, to = unpack(me)
        local async = _AST.iter(_AST.pred_async)()
        if async and (not to) then
            ASR( async.depth <= _AST.iter'SetBlock'().depth+1, me,
                    'invalid access from async')
        end

        if _AST.iter'BlockI'() then
            CLS().has_pre = true   -- code for pre (before constr)
        end
    end,

    SetVal = function (me)
        -- new, spawn, async, await
        ASR(not _AST.iter'BlockI'(), me,
                'not permitted inside an interface')
    end,

    Var = function (me)
        local async = _AST.iter(_AST.pred_async)()
        if async then
            ASR(_AST.iter'VarList'() or         -- param list
                me.ret or                       -- var assigned on return
                async.depth < me.var.blk.depth, -- var is declared inside
                    me, 'invalid access from async')
        end
    end,

    Op1_cast = function (me)
        local tp, _ = unpack(me)
        local _tp = _TP.deref(tp)
        if _tp and _ENV.clss[_tp] then
            _PROPS.has_ifcs = true      -- cast must check org->cls_id
        end
    end
}

_AST.visit(F)

end

    
do
-- TODO: rename to flow
_ANA = {
    ana = {
        isForever  = nil,
        reachs   = 0,      -- unexpected reaches
        unreachs = 0,      -- unexpected unreaches
    },
}

-- avoids counting twice (due to loops)
-- TODO: remove
local __inc = {}
function INC (me, c)
    if __inc[me] then
        return true
    else
        _ANA.ana[c] = _ANA.ana[c] + 1
        __inc[me] = true
        return false
    end
end

-- [false]  => never terminates
-- [true]   => terminates w/o event

function OR (me, sub, short)

    -- TODO: short
    -- short: for ParOr/Loop/SetBlock if any sub.pos is equal to me.pre,
    -- then we have a "short circuit"

    for k in pairs(sub.ana.pos) do
        if k ~= false then
            me.ana.pos[false] = nil      -- remove NEVER
            me.ana.pos[k] = true
        end
    end
end

function COPY (n)
    local ret = {}
    for k in pairs(n) do
        ret[k] = true
    end
    return ret
end

function _ANA.CMP (n1, n2)
    return _ANA.HAS(n1, n2) and _ANA.HAS(n2, n1)
end

function _ANA.HAS (n1, n2)
    for k2 in pairs(n2) do
        if not n1[k2] then
            return false
        end
    end
    return true
end

local LST = {
    Do=true, Stmts=true, Block=true, Root=true, Dcl_cls=true,
    Pause=true,
}

F = {
    Root_pos = function (me)
        _ANA.ana.isForever = not (not me.ana.pos[false])
    end,

    Node_pre = function (me)
        if me.ana then
            return
        end

        local top = _AST.iter()()
        me.ana = {
            pre  = (top and top.ana.pre) or { [true]=true },
        }
    end,
    Node = function (me)
        if me.ana.pos then
            return
        end
        if LST[me.tag] and me[#me] then
            me.ana.pos = COPY(me[#me].ana.pos)  -- copy lst child pos
        else
            me.ana.pos = COPY(me.ana.pre)       -- or copy own pre
        end
    end,

    Dcl_cls_pre = function (me)
        if me ~= _MAIN then
            me.ana.pre = { [me.id]=true }
        end
    end,
    Orgs = function (me)
        me.ana.pos = { [false]=true }       -- orgs run forever
    end,

    Stmts_bef = function (me, sub, i)
        if i == 1 then
            -- first sub copies parent
            sub.ana = {
                pre = COPY(me.ana.pre)
            }
        else
            -- broken sequences
            if me[i-1].ana.pos[false] and (not me[i-1].ana.pre[false]) then
                --_ANA.ana.unreachs = _ANA.ana.unreachs + 1
                me.__unreach = true
                WRN( INC(me, 'unreachs'),
                     sub, 'statement is not reachable')
            end
            -- other subs follow previous
            sub.ana = {
                pre = COPY(me[i-1].ana.pos)
            }
        end
    end,

    ParOr_pos = function (me)
        me.ana.pos = { [false]=true }
        for _, sub in ipairs(me) do
            OR(me, sub, true)
        end
        if me.ana.pos[false] then
            --_ANA.ana.unreachs = _ANA.ana.unreachs + 1
            WRN( INC(me, 'unreachs'),
                 me, 'at least one trail should terminate')
        end
    end,

    ParAnd_pos = function (me)
        -- if any of the sides run forever, then me does too
        -- otherwise, behave like ParOr
        for _, sub in ipairs(me) do
            if sub.ana.pos[false] then
                me.ana.pos = { [false]=true }
                --_ANA.ana.unreachs = _ANA.ana.unreachs + 1
                WRN( INC(me, 'unreachs'),
                     sub, 'trail should terminate')
                return
            end
        end

        -- like ParOr, but remove [true]
        local onlyTrue = true
        me.ana.pos = { [false]=true }
        for _, sub in ipairs(me) do
            OR(me, sub)
            if not sub.ana.pos[true] then
                onlyTrue = false
            end
        end
        if not onlyTrue then
            me.ana.pos[true] = nil
        end
    end,

    ParEver_pos = function (me)
        me.ana.pos = { [false]=true }
        local ok = false
        for _, sub in ipairs(me) do
            if sub.ana.pos[false] then
                ok = true
                break
            end
        end
        if not ok then
            --_ANA.ana.reachs = _ANA.ana.reachs + 1
            WRN( INC(me, 'reachs'),
                 me, 'all trails terminate')
        end
    end,

    If = function (me)
        me.ana.pos = { [false]=true }
        for _, sub in ipairs{me[2],me[3]} do
            OR(me, sub)
        end
    end,

    SetBlock_pre = function (me)
        me.ana.pos = { [false]=true }   -- `return/break´ may change this
    end,
    Return = function (me)
        local top = _AST.iter((me.tag=='Return' and 'SetBlock') or 'Loop')()
        me.ana.pos = COPY(me.ana.pre)
        OR(top, me, true)
        me.ana.pos = { [false]='esc' }   -- diff from [false]=true
    end,
    SetBlock = function (me)
        local blk = me[1]
        if not blk.ana.pos[false] then
            --_ANA.ana.reachs = _ANA.ana.reachs + 1
            WRN( INC(me, 'reachs'),
                 blk, 'missing `return´ statement for the block')
        end
    end,

    Loop_pre = 'SetBlock_pre',
    Break    = 'Return',

    Loop = function (me)
        if me.isBounded then
            me.ana.pos = COPY(me[1].ana.pos)
            return      -- guaranteed to terminate
        end

        if me[1].ana.pos[false] then
            --_ANA.ana.unreachs = _ANA.ana.unreachs + 1
            WRN( INC(me, 'unreachs'),
                 me, '`loop´ iteration is not reachable')
        end
    end,

    Thread = 'Async',
    Async = function (me)
        if me.ana.pre[false] then
            me.ana.pos = COPY(me.ana.pre)
        else
            me.ana.pos = { ['ASYNC_'..me.n]=true }  -- assume it terminates
        end
    end,

--[[
-- TODO: remove
-- not needed after SetAwait => AwaitX;SetExp
    SetAwait = function (me)
        local _, awt, set = unpack(me)
        set.ana.pre = COPY(awt.ana.pos)
        set.ana.pos = COPY(awt.ana.pos)
        me.ana.pre = COPY(awt.ana.pre)
        me.ana.pos = COPY(set.ana.pos)
    end,
]]

    AwaitS = function (me)
        DBG'TODO - ana.lua - AwaitS'
    end,

    AwaitExt_aft = function (me, sub, i)
        if i > 1 then
            return
        end

        -- between Await and Until

        local awt, cnd = unpack(me)

        local t
        if me.ana.pre[false] then
            t = { [false]=true }
        else
            -- use a table to differentiate each instance
            t = { [{awt.evt and awt.evt or 'WCLOCK'}]=true }
        end
        me.ana.pos = COPY(t)
        if cnd then
            cnd.ana = {
                pre = COPY(t),
            }
        end
    end,
    AwaitInt_aft = 'AwaitExt_aft',
    AwaitT_aft   = 'AwaitExt_aft',

    AwaitN = function (me)
        me.ana.pos = { [false]=true }
    end,
}

local _union = function (a, b, keep)
    if not keep then
        local old = a
        a = {}
        for k in pairs(old) do
            a[k] = true
        end
    end
    for k in pairs(b) do
        a[k] = true
    end
    return a
end

-- TODO: remove
-- if nested node is reachable from "pre", join with loop POS
function _ANA.union (root, pre, POS)
    local t = {
        Node = function (me)
            if me.ana.pre[pre] then         -- if matches loop begin
                _union(me.ana.pre, POS, true)
            end
        end,
    }
    _AST.visit(t, root)
end

_AST.visit(F)

end

    
do
_ANA.ana.acc  = 0      -- nd accesses
_ANA.ana.abrt  = 0      -- nd flows
_ANA.ana.excpt = 0      -- nd excpt

-- any variable access calls this function
-- to be inserted on parent Parallel sub[i] or Class
function iter (n)
    local par = n.__par and n.__par.tag
    return par=='ParOr' or par=='ParAnd' or par=='ParEver'
        or n.tag=='Dcl_cls'
end

function INS (acc, exists)
    if _AST.iter'Thread'() then
        acc.md = 'no'                       -- no acc inside threads
    end

    if not exists then
        acc.cls = CLS()                     -- cls that acc resides
    end
    local n = _AST.iter(iter)()             -- child Block from PAR
    if n then
        n.ana.accs[#n.ana.accs+1] = acc
    end
    return acc
end

function CHG (acc, md)
    if _AST.iter'Thread'() then
        return
    end
    acc.md = md
end

F = {
-- accs need to be I-indexed (see CHK_ACC)
    Dcl_cls_pre = function (me)
        me.ana.accs = {}
    end,
    ParOr_pre = function (me)
        for _, sub in ipairs(me) do
            sub.ana.accs = {}
        end
    end,
    ParAnd_pre  = 'ParOr_pre',
    ParEver_pre = 'ParOr_pre',

    ParOr_pos = function (me)
        -- insert all my subs on my parent Par
        if _AST.iter(_AST.pred_par) then -- requires ParX_pos
            for _, sub in ipairs(me) do
                for _,acc in ipairs(sub.ana.accs) do
    -- check par/enter only against immediate pars
                    if acc.md ~= 'par' then
    -- check ParOr esc only against immediate pars
                    if not (acc.md=='esc' and acc.id.tag=='ParOr') then
    -- check Loop esc only against nested pars
                    --if not (acc.md=='esc' and acc.id.tag=='Loop'
                            --and acc.id.depth>me.depth) then
                        INS(acc, true)
                    --end
                    end
                    end
                end
            end
        end
    end,
    ParAnd_pos  = 'ParOr_pos',
    ParEver_pos = 'ParAnd_pos',

    Spawn = 'New',
    New = function (me)
        for _,acc in ipairs(me.cls.ana.accs) do
            INS(acc, true)
        end
    end,

-- TODO: usar o Dcl_var p/ isso
--[=[
    Orgs = function (me)
        -- insert cls accs on my parent ParOr
        for _, var in ipairs(me.vars) do
            for _,acc in ipairs(var.cls.ana.accs) do
                INS(acc, true)
            end
        end
    end,
]=]

    EmitExt = function (me)
        local e1, e2 = unpack(me)
        if e1.evt.pre == 'input' then
            return
        end
        INS {
            path = me.ana.pre,
            id  = e1.evt.id,    -- like functions (not table events)
            md  = 'cl',
            tp  = '_',
            any = false,
            err = 'event `'..e1.evt.id..'´ (line '..me.ln[2]..')'
        }
--[[
        if e2 then
            local tp = _TP.deref(e1.evt.tp, true)
            if e2.accs and tp then
                e2.accs[1][4] = (e2.accs[1][2] ~= 'no')   -- &x does not become 
                    "any"
                e2.accs[1][2] = (me.c and me.c.mod=='pure' and 'rd') or 'wr'
                e2.accs[1][3] = tp
            end
        end
]]
    end,

    Op2_call = function (me)
        local _, f, exps = unpack(me)
        local ps = {}
        CHG(f.ref.acc, 'cl')
        for i, exp in ipairs(exps) do
            local tp = _TP.deref(exp.tp, true)
            if tp then
                local v = exp.ref
                if v then   -- ignore constants
--DBG(exp.tag, exp.ref)
                    v.acc.any = exp.lval    -- f(&x) // a[N] f(a) // not "any"
                    CHG(v.acc, (me.c and me.c.mod=='pure' and 'rd') or 'wr')
                    v.acc.tp  = tp
                end
            end
        end
    end,

    EmitInt = function (me)
        local e1, e2 = unpack(me)
        CHG(e1.ref.acc, 'tr')
        e1.ref.acc.node = me        -- emtChk
        me.emtChk = false
    end,

    SetExp = function (me)
        local _,_,to = unpack(me)
        CHG(to.ref.acc, 'wr')
    end,
    AwaitInt = function (me)
        CHG(me[1].ref.acc, 'aw')
        F.AwaitExt(me)  -- flow
    end,

    ['Op1_*'] = function (me)
        me.ref.acc.any = true
        me.ref.acc.tp  = _TP.deref(me.ref.acc.tp,true)
    end,
    ['Op1_&'] = function (me)
        CHG(me.ref.acc, 'no')
    end,

    ['Op2_.'] = function (me)
        if me.org then
            me.ref.acc.org = me.org.ref
        end
    end,

    Global = function (me)
        me.acc = INS {
            path = me.ana.pre,
            id  = 'Global',
            md  = 'rd',
            tp  = me.tp,
            any = true,
            err = 'variable `global´ (line '..me.ln[2]..')',
        }
    end,

    This = function (me)
        me.acc = INS {
            path = me.ana.pre,
            id  = me,
            md  = 'rd',
            tp  = me.tp,
            any = true,
            err = 'variable `this´ (line '..me.ln[2]..')',
        }
    end,

    Var = function (me)
        me.acc = INS {
            path = me.ana.pre,
            id  = me.var,
            md  = 'rd',
            tp  = me.var.tp,
            any = false,
            err = 'variable/event `'..me.var.id..'´ (line '..me.ln[2]..')',
        }
    end,

    Nat = function (me)
        me.acc = INS {
            path = me.ana.pre,
            id  = me[1],
            md  = 'rd',
            tp  = '_',
            any = false,
            err = 'symbol `'..me[1]..'´ (line '..me.ln[2]..')',
        }
    end,

    -- FLOW --

    Break = function (me, TAG, PRE)
        TAG = TAG or 'Loop'
        PRE = PRE or me.ana.pre
        local top = _AST.iter(TAG)()
        INS {
            path = PRE,
            id  = top,
            md  = 'esc',
            err = 'escape (line '..me.ln[2]..')',
        }
    end,
    Return = function (me)
        F.Break(me, 'SetBlock')
    end,
    Node = function (me)
        local top = me.__par and me.__par.tag
        if top == 'ParOr' then
            if not me.ana.pos[false] then
                F.Break(me, 'ParOr', me.ana.pos)
            end
        end

        if top=='ParOr' or top=='ParAnd' or top=='ParEver' then
            if not me.ana.pre[false] then
                me.parChk = false           -- only chk if ND flw
                INS {
                    path = me.ana.pre,
                    id   = me,--.__par,
                    md   = 'par',
                    err  = 'par enter (line '..me.ln[2]..')',
                }
            end
        end
    end,

    AwaitExt = function (me)
        INS {
            path = me.ana.pos,
            id  = me,--_AST.iter(TAG)(),
            md  = 'awk',
            err = 'awake (line '..me.ln[2]..')',
        }
    end,
    AwaitT = 'AwaitExt',
    --AwaitInt = <see above>,
}

_AST.visit(F)

------------------------------------------------------------------------------

local ND = {
    acc = { par={},awk={},esc={},
        cl  = { cl=true, tr=true,  wr=true,  rd=true,  aw=true  },
        tr  = { cl=true, tr=true,  wr=false, rd=false, aw=true  },
        wr  = { cl=true, tr=false, wr=true,  rd=true,  aw=false },
        rd  = { cl=true, tr=false, wr=true,  rd=false, aw=false },
        aw  = { cl=true, tr=true,  wr=false, rd=false, aw=false },
        no  = {},   -- never ND ('ref')
    },

    flw = { cl={},tr={},wr={},rd={},aw={},no={},
        par = { par=false, awk=false, esc=true },
        awk = { par=false, awk=false, esc=true },
        esc = { par=true,  awk=true,  esc=true },
    },
}

local ALL = nil     -- holds all emits starting from top-most PAR

--[[
    ana = {
        acc = 1,  -- false positive
    },
    ana = {
        isForever = true,
        n_unreachs = 1,
    },
]]

-- {path [A]=true, [a]=true } => {ret [A]=true, [aX]=true,[aY]=true }
-- {T [a]={[X]=true,[Y]=true} } (emits2pres)
local function int2exts (path, NO_emts, ret)
    ret = ret or {}

    local more = false                  -- converged
    for int in pairs(path) do
        if type(int)=='table' and int[1].pre=='event' then
            for emt_acc in pairs(ALL) do
                if int[1]==emt_acc.id and (not NO_emts[emt_acc]) then
                    for ext in pairs(emt_acc.path) do
                        if not ret[ext] then
                            more = true         -- not converged yet
                            ret[ext] = true     -- insert new ext
                        end
                    end
                end
            end
        else
            ret[int] = true             -- already an ext
        end
    end
    if more then
        return int2exts(ret, NO_emts, ret, cache) -- not converged
    else
        if next(ret)==nil then
            ret[false] = true   -- include "never" if empty
        end
        return ret
    end
end

function par_rem (path, NO_par)
    for id in pairs(path) do
        if NO_par[id] then
            path[id] = nil
        end
    end
    if next(path)==nil then
        path[true] = true       -- include "tight" became empty
    end
    return path
end

function par_isConc (path1, path2, T)
    for id1 in pairs(path1) do
        for id2 in pairs(path2) do
            if (id1 == false) then
            elseif (id1 == id2) or
                     (type(id1) == 'table') and (type(id2) == 'table') and
                     (id1[1] == id2[1])
            then
                return true
            end
        end
    end
end

--local CACHE = setmetatable({},
    --{__index=function(t,k) t[k]={} return t[k] end})

function CHK_ACC (accs1, accs2, NO_par, NO_emts)
    local cls = CLS()

    -- "acc": i/j are concurrent, and have incomp. acc
    -- accs need to be I-indexed
    for _, acc1 in ipairs(accs1) do
        local path1 = int2exts(acc1.path, NO_emts)
              path1 = par_rem(path1, NO_par)
        for _, acc2 in ipairs(accs2) do
            local path2 = int2exts(acc2.path, NO_emts)
                  path2 = par_rem(path2, NO_par)
            if par_isConc(path1,path2) then

-- FLOW
                if ND.flw[acc1.md][acc2.md] then
                    if _AST.isChild(acc1.id, acc2.id)
                    or _AST.isChild(acc2.id, acc1.id)
                    then
                        DBG('WRN : abortion : '..
                                acc1.err..' vs '..acc2.err)
                        _ANA.ana.abrt = _ANA.ana.abrt + 1
--[[
DBG'==============='
DBG(acc1.cls.id, acc1, acc1.id, acc1.md, acc1.tp, acc1.any, acc1.err)
for k in pairs(path1) do
    DBG('path1', acc1.path, type(k)=='table' and k[1].id or k)
end
DBG(acc2.cls.id, acc2, acc2.id, acc2.md, acc2.tp, acc2.any, acc2.err)
for k in pairs(path2) do
    DBG('path2', acc2.path, type(k)=='table' and k[1].id or k)
end
DBG'==============='
]]
                        if acc1.md == 'par' then
                            acc1.id.parChk = true
                        end
                        if acc2.md == 'par' then
                            acc2.id.parChk = true
                        end
                    end
                end

-- ACC
                if ND.acc[acc1.md][acc2.md] then
                    -- this.x vs this.x (both accs bounded to cls)
                    local cls_ = (acc1.cls == cls) or
                                 (acc2.cls == cls)

                    -- a.x vs this.x
                    local _nil = {}
                    local o1 = (acc1.org or acc2.org)
                    o1 = o1 and o1.acc or _nil
                    local o2 = (acc2.org or acc1.org)
                    o2 = o2 and o2.acc or _nil

                    -- orgs are compatible
                    local org_ = (o1 == o2)
                              or o1.any
                              or o2.any

                    -- orgs are compatible
                    local org_ = o1.id == o2.id
                              or o1.any
                              or o2.any

                    -- ids are compatible
                    local id_ = acc1.id == acc2.id
                             or acc1.md=='cl' and acc2.md=='cl'
                             or acc1.any and _TP.contains(acc1.tp,acc2.tp)
                             or acc2.any and _TP.contains(acc2.tp,acc1.tp)

                    -- C's are det
                    local c1 = _ENV.c[acc1.id]
                    c1 = c1 and (c1.mod=='pure' or c1.mod=='constant')
                    local c2 = _ENV.c[acc2.id]
                    c2 = c2 and (c2.mod=='pure' or c2.mod=='constant')
                    local c_ = c1 or c2
                            or (_ENV.dets[acc1.id] and _ENV.dets[acc1.id][acc2.id])

        --DBG(id_, c_,c1,c2, acc1.any,acc2.any)
                    if cls_ and org_ and id_ and (not c_)
                    then
                        if _OPTS.warn_nondeterminism then
                            DBG('WRN : nondeterminism : '..acc1.err
                                    ..' vs '..acc2.err)
                        end
                        _ANA.ana.acc = _ANA.ana.acc + 1
                    end
                end
            end
        end
    end
end

function _chk (n, id)
    for k in pairs(n) do
        if type(k)=='table' and k[1]==id then
            return true
        end
    end
    return false
end

-- TODO: join with CHK_ACC
-- emits vs rets/ors/breaks (the problem is that emits are considered in par)
function CHK_EXCPT (s1, s2, isOR)
    for _, ana in ipairs(s1.ana.accs) do
        if ana.md == 'tr' then
            if _chk(s2.ana.pos,ana.id) and isOR or -- terminates w/ same event
               s2.ana.pos[false] --or       -- ~terminates (return/break)
               --s2.ana.pos[true]                 -- terminates tight
            then
                if _OPTS.warn_exception then
                    DBG('WRN : exception : line '..s2.ln[2]..' vs '..ana.err)
                end
                _ANA.ana.excpt = _ANA.ana.excpt + 1
                ana.node.emtChk = true
            end
        end
    end
end

G = {
-- take all emits from top-level PAR
    ParOr_pre = function (me)
        if ALL then
            return
        end
        ALL = {}
        for _, sub in ipairs(me) do
            for _,acc in ipairs(sub.ana.accs) do
                if acc.md == 'tr' then
                    ALL[acc] = true
                end
            end
        end
    end,
    ParAnd_pre  = 'ParOr_pre',
    ParEver_pre = 'ParOr_pre',

-- look for nondeterminism
    ParOr = function (me)
        for i=1, #me do
            for j=i+1, #me do

                -- holds invalid emits
                local NO_emts = {}
                for _,acc in ipairs(me[i].ana.accs) do
                    if acc.md == 'tr' then
                        NO_emts[acc] = true -- same trail (happens bef or aft)
                    end
                end
                for _,acc in ipairs(me[j].ana.accs) do
                    if acc.md == 'tr' then
                        NO_emts[acc] = true -- same trail (happens bef or aft)
                    end
                end
                for acc in pairs(ALL) do
                    if _ANA.CMP(acc.path, me.ana.pre) then
                        NO_emts[acc] = true -- instantaneous emit
                    end
                end

                CHK_ACC(me[i].ana.accs, me[j].ana.accs,
                        me.ana.pre,
                        --_ANA.union(me.ana.pre,me.ana.pos),
                        NO_emts)
                CHK_EXCPT(me[i], me[j], me.tag=='ParOr')
                CHK_EXCPT(me[j], me[i], me.tag=='ParOr')
            end
        end
    end,
    ParAnd  = 'ParOr',
    ParEver = 'ParOr',

-- TODO: workaround
    -- Loop can only be repeated after nested PARs evaluate CHK_*
    Loop = function (me)
        -- pre = pre U pos
        if not me[1].ana.pos[false] then
            _ANA.union(me[1], next(me.ana.pre), me[1].ana.pos)
        end
    end,
}

_AST.visit(G)

end

    --_AST.dump(_AST.root)
    
do
function MAX_all (me, t)
    t = t or me
    for _, sub in ipairs(t) do
        if _AST.isNode(sub) then
            me.trails_n = MAX(me.trails_n, sub.trails_n)
        end
    end
end

F = {
    Node_pre = function (me)
        me.trails_n = 1
    end,
    Node_pos = function (me)
        if not F[me.tag] then
            MAX_all(me)
        end
    end,

    If = function (me)
        local c, t, f = unpack(me)
        MAX_all(me, {t,f})
    end,

    Dcl_cls = function (me)
        MAX_all(me)

        -- pointer to next org or parent/trail
        -- [ IN__ORG_UP/DOWN ]
        if me ~= _MAIN then
            me.trails_n = me.trails_n + 1
        end

        ASR(me.trails_n < 256, me, 'too many trails')
    end,
    Dcl_var = function (me)
        if me.var.cls then
            me.var.blk.trl_orgs = true
        end
    end,

    New = function (me)
        me.blk.trl_orgs = true
    end,
    Spawn = 'New',

    Block = function (me)
        MAX_all(me)

        if me.fins then
            -- implicit await in parallel
            me.trails_n = me.trails_n + 1
        end

        -- pointer to my first org
        -- clear trail
        -- [ CLR | IN__ORG | STMTS | FIN ]
        if me.trl_orgs then
            me.trails_n = me.trails_n + 1 + 1
        end
    end,

    ParAnd  = 'ParOr',
    ParEver = 'ParOr',
    ParOr = function (me)
        me.trails_n = 0
        for _, sub in ipairs(me) do
            me.trails_n = me.trails_n + sub.trails_n
        end
    end,
}

_AST.visit(F)

-------------------------------------------------------------------------------

function pred (n)
    return n.trails
end

G = {
    Root_pre = 'Dcl_cls_pre',
    Dcl_cls_pre = function (me)
        me.trails  = { 0, me.trails_n -1 }     -- [0, N]
    end,

    Node = function (me)
        if me.trails then
            return
        end
        me.trails  = _AST.iter(pred)().trails
    end,

    Block_pre = function (me)
        local stmts = unpack(me)

        -- [ 1, 1, S, 1 ] (clr, org0, stmts, fin)

        me.trails = me.trails or _AST.iter(pred)().trails

        local t0 = me.trails[1]

        -- ORGS (pointer to the first org here)
        -- (this is not the linked list from my parent)
        -- [ IN__ORGS_DOWN | fst | lst ]
        if me.trl_orgs then
            t0 = t0 + 1                 -- clr
            me.trl_orgs = { t0, t0 }
                t0 = t0 + 1             -- org0
        end

        -- BLOCK
        stmts.trails = { t0, t0+stmts.trails_n-1 }
            t0 = t0 + stmts.trails_n    -- stmts

        -- FINS (must be the last to proper nest fins)
        if me.fins then
            me.trl_fins  = { t0, t0 }
                t0 = t0 + 1             -- fin
        end
    end,

    _Par_pre = function (me)
        me.trails = _AST.iter(pred)().trails

        for i, sub in ipairs(me) do
            sub.trails = {}
            if i == 1 then
                sub.trails[1] = me.trails[1]
            else
                local pre = me[i-1]
                sub.trails[1] = pre.trails[1] + pre.trails_n
            end
            sub.trails[2] = sub.trails[1] + sub.trails_n  - 1
        end
    end,

    ParOr_pre   = '_Par_pre',
    ParAnd_pre  = '_Par_pre',
    ParEver_pre = '_Par_pre',
}

_AST.visit(G)

end

    
do
local _ceu2c = { ['or']='||', ['and']='&&', ['not']='!' }
local function ceu2c (op)
    return _ceu2c[op] or op
end

F =
{
    Dcl_var = function (me)
        if me.var.cls then
            if me.var.arr then
                ASR(me.var.arr.sval, me, 'invalid static expression')
            end
        end
    end,

    Op2_call = function (me)
        local _, f, exps = unpack(me)
        if f.org then
            return
        end
        local ps = {}
        for i, exp in ipairs(exps) do
            if not exp.cval then
                return
            end
            ps[i] = exp.cval
        end
        me.cval = f.cval..'('..table.concat(ps,',')..')'
    end,

    Op2_any = function (me)
        local op, e1, e2 = unpack(me)
        if e1.cval and e2.cval then
            me.cval = '('..e1.cval..ceu2c(op)..e2.cval..')'
        end

        if e1.sval and e2.sval then
            local v = loadstring('return '..e1.sval..op..e2.sval)
            me.sval = v and tonumber(v())
        end
    end,
    ['Op2_-']   = 'Op2_any',
    ['Op2_+']   = 'Op2_any',
    ['Op2_%']   = 'Op2_any',
    ['Op2_*']   = 'Op2_any',
    ['Op2_/']   = 'Op2_any',
    ['Op2_|']   = 'Op2_any',
    ['Op2_&']   = 'Op2_any',
    ['Op2_<<']  = 'Op2_any',
    ['Op2_>>']  = 'Op2_any',
    ['Op2_^']   = 'Op2_any',
    ['Op2_==']  = 'Op2_any',
    ['Op2_!=']  = 'Op2_any',
    ['Op2_>=']  = 'Op2_any',
    ['Op2_<=']  = 'Op2_any',
    ['Op2_>']   = 'Op2_any',
    ['Op2_<']   = 'Op2_any',
    ['Op2_or']  = 'Op2_any',
    ['Op2_and'] = 'Op2_any',

    Op1_any = function (me)
        local op, e1 = unpack(me)
        if e1.cval then
            me.cval = '('..ceu2c(op)..e1.cval..')'
        end
        if e1.sval then
            local v = loadstring(op..e1.sval)
            me.sval = v and tonumber(v())
        end
    end,
    ['Op1_~']   = 'Op1_any',
    ['Op1_-']   = 'Op1_any',
    ['Op1_not'] = 'Op1_any',

    Op1_cast = function (me)
        local tp, exp = unpack(me)
        if exp.cval then
            me.cval = '(('.._TP.c(tp)..')'..exp.cval..')'
        end
    end,

    RawExp = function (me)
        me.cval = unpack(me)
    end,

    Nat = function (me)
        me.cval = string.sub(me[1], 2)
    end,
    SIZEOF = function (me)
        local tp = unpack(me)
        if type(tp) == 'string' then
            me.cval = 'sizeof('.._TP.c(me[1])..')'
        end

        if type(tp) == 'string' then    -- sizeof(type) vs sizeof(exp)
            local t = (_TP.deref(tp) and _ENV.c.pointer) or _ENV.c[tp]
            ASR(t and (t.tag=='type' or t.tag=='unk'), me,
                    'undeclared type '..tp)
            t.tag = 'type'
            me.sval = t and t.len
        end
    end,
    STRING = function (me)
        me.cval = me[1]
    end,
    CONST = function (me)
        me.cval = me[1]
        me.sval = tonumber(me[1])
    end,
    NULL = function (me)
        me.cval = '((void *)0)'
        me.sval = '((void *)0)'
    end,
}

_AST.visit(F)

end

    
do
_LBLS = {
    list = {},      -- { [lbl]={}, [i]=lbl }
    code_enum = '',
    code_fins = '',
}

function new (lbl)
    if lbl[2] then
        lbl.id = lbl[1]
    else
        lbl.id = CLS().id..'_'..lbl[1]..'_'..#_LBLS.list
    end
    lbl.id = string.gsub(lbl.id, '%*','')
    lbl.id = string.gsub(lbl.id, '%.','')
    lbl.id = string.gsub(lbl.id, '%$','')
    lbl.id = string.gsub(lbl.id, '%%','')
    _LBLS.list[lbl] = true
    lbl.n = #_LBLS.list                   -- starts from 0
    _LBLS.list[#_LBLS.list+1] = lbl

    for n in _AST.iter() do
        if n.lbls_all then
            n.lbls_all[lbl] = true
        end
    end

    return lbl
end

F = {
    Node_pre = function (me)
        me.lbls = { #_LBLS.list }
    end,
    Node = function (me)
        me.lbls[2] = #_LBLS.list-1
    end,

    Root_pre = function (me)
        --new{'CEU_INACTIVE', true}
    end,
    Root = function (me)
        -- 0, 1,-1, tot,-tot
        -- <0 = off (for internal events)
        _ENV.c.tceu_nlbl.len  = _TP.n2bytes(1+2 + #_LBLS.list*2)

        -- enum of labels
        for i, lbl in ipairs(_LBLS.list) do
            _LBLS.code_enum = _LBLS.code_enum..'    '
                                ..lbl.id..' = '..lbl.n..',\n'
        end

        -- labels which are finalizers
        local t = {}
        for _, lbl in ipairs(_LBLS.list) do
            t[#t+1] = string.find(lbl.id,'__fin') and assert(lbl.depth) or 0
        end
        _LBLS.code_fins = table.concat(t,',')
    end,

    Block = function (me)
        local blk = unpack(me)

        if me.fins then
            me.lbl_fin     = new{'Block__fin', depth=me.depth}
            me.lbl_fin_cnt = new{'Block_fin_cnt'}
        end
    end,

    Dcl_cls = function (me)
        me.lbl = new{'Class_'..me.id, true}
        if me.has_pre then
            me.lbl_pre = new{'Class_Pre_'..me.id}
        end
-- TODO (-RAM)
        --if i_am_instantiable then
            me.lbl_clr = new{'Class_free_'..me.id}
        --end
    end,
    New = function (me)
        me.lbls_cnt = { new{me.tag..'_cont'} }
        if me.cls.has_pre then
            me.lbls_pre = { new{'Pre_cnt'} }
        end
    end,
    Spawn = 'New',
    Free  = function (me)
        me.lbl_clr = new{'Free_clr'}
    end,

    SetBlock_pre = function (me)
        me.lbl_out = new{'Set_out',  prio=me.depth}
    end,

    _Par_pre = function (me)
        me.lbls_in = {}
        for i, sub in ipairs(me) do
            if i > 1 then
                me.lbls_in[i] = new{me.tag..'_sub_'..i}
            end
        end
    end,
    ParEver_pre = function (me)
        F._Par_pre(me)
        me.lbl_out = new{'ParEver_out'}
    end,
    ParOr_pre = function (me)
        F._Par_pre(me)
        me.lbl_out = new{'ParOr_out',  prio=me.depth}
    end,
    ParAnd_pre = function (me)
        F._Par_pre(me)
        me.lbl_tst = new{'ParAnd_chk'}
        me.lbl_out = new{'ParAnd_out'}
    end,

    Thread = 'Async',
    Async = function (me)
        me.lbl = new{'Async'}
    end,

    Loop_pre = function (me)
        if _AST.iter'Async'() then
            me.lbl_asy = new{'Async_cnt'}
        end
    end,

    EmitExt = function (me)
        -- only async needs to break up (avoids stack growth)
        if _AST.iter'Async'() then
            me.lbl_cnt = new{'Async_cont'}
        end
    end,
    EmitT = function (me)
        -- only async needs to break up (avoids stack growth)
        if _AST.iter'Async'() then
            me.lbl_cnt = new{'Async_cont'}
        end
    end,
    EmitInt = function (me)
        me.lbl_cnt = new{'EmitInt_cont'}
    end,
    Dcl_var = function (me)
        if me.var.cls then
            if me.var.cls.has_pre then
                me.lbls_pre = {}
                for i=1, (me.var.arr and me.var.arr.sval or 1) do
                    me.lbls_pre[i] = new{'Pre_cnt'}
                end
            end

            me.lbls_cnt = {}
            for i=1, (me.var.arr and me.var.arr.sval or 1) do
                me.lbls_cnt[i] = new{'Start_cnt'}
            end
        end
    end,

    AwaitS = function (me)
        me.lbl = new{'Awake_MANY'}
    end,
    AwaitT = function (me)
        me.lbl = new{'Awake_DT'}
    end,
    AwaitExt = function (me)
        local e = unpack(me)
        me.lbl = new{'Awake_'..e.evt.id}
    end,
    AwaitInt = 'AwaitExt',

    ParOr_pos = function (me)
        if me.needs_clr then
            me.lbl_clr = new{'Clear'}
        end
    end,
    Block_pos    = 'ParOr_pos',
    Loop_pos     = 'ParOr_pos',
    SetBlock_pos = 'ParOr_pos',
}

_AST.visit(F)

end

    
do
local VARS = {}

if not _ANA then
    return          -- isTmp=false for all vars
end

F = {
    Dcl_var_pre = function (me)
        local var = me.var
        if var.isEvt or var.cls or var.inTop then
            return                  -- only normal vars can be tmp
        end
        VARS[var] = true
        var.isTmp = true          -- TODO: always "false" by now
    end,

    Var = function (me)
        local var = me.var

        if _AST.iter'Thread'() then
            return                  -- all threads vars are "tmp"
        end

        if var.isEvt or var.cls then
            var.isTmp = false
            return                  -- only normal vars can be tmp
        end

        local glb = _ENV.clss.Global
        if var.inTop or
            (var.blk==_ENV.clss.Main.blk_ifc and glb and glb.is_ifc and
             glb.blk_ifc.vars[var.id])
        then
            var.isTmp = false
            return                  -- vars in interfaces cannot be tmp
        end

        local dcl = _AST.iter'Dcl_var'()
        if dcl and dcl[1]==var.id then
            return                  -- my declaration is not an access
        end

        if me.__par.tag == 'SetBlock' then
            return                  -- set is performed on respective `return´
        end

        local v = VARS[var]

        local op = _AST.iter'Op1_&'()
        local isRef = op and (op.ref == me)

        if _AST.iter'Finally'() or      -- finally executes through "call"
           _AST.iter'AwaitInt'() or     -- await ptr:a (ptr is tested on awake)
           isRef or                     -- reference may escape
           var.arr                      -- array may escape: TODO conservative
                                        -- (arrays as parameters)
        then
            var.isTmp = false
            VARS[var] = nil
            return
        end

        if v == true then
            VARS[var] = me.ana.pre
            return                  -- first access
        end

        if not (v and _ANA.CMP(v,me.ana.pre)) then
            var.isTmp = false       -- found a Par or Await in the path
            return
        end
    end,

    EmitInt = function (me)
        VARS = {}   -- NO: run in different ceu_call
    end,

    Loop_pre = function (me)
        if (me.noAwtsEmts and (not _AST.iter(_AST.pred_async)())) or
            me.isAwaitUntil then
            return      -- OK: (tight loop outside Async) or (await ... until)
        end
        VARS = {}       -- NO: loop in between Dcl/Accs is dangerous
        --[[
            -- x is on the stack but may be written in two diff reactions
            -- a non-ceu code can reuse the stack in between
            input int E;
            var int x;
            loop do
                var int tmp = await E;
                if tmp == 0 then
                    break;
                end
                x = tmp;
            end
            return x;
        ]]
    end,
--[[
]]

    ParOr_pre = function (me)
        for var, v in pairs(VARS) do
            if v ~= true then
                VARS[var] = nil     -- remove previously accessed vars
            end
        end
    end,
    ParAnd_pre  = 'ParOr_pre',
    ParEver_pre = 'ParOr_pre',
    ParOr   = 'ParOr_pre',
    ParAnd  = 'ParOr_pre',
    ParEver = 'ParOr_pre',

    -- TODO: should pre's be already different?
    Async_pre = 'ParOr_pre',
    Async     = 'ParOr_pre',
}

_AST.visit(F)

end

    
do
_MEM = {
    cls = {},       -- offsets for fixed fields inside classes
    evt_off = 0,    -- max event index among all classes
    clss_defs  = nil,
    clss_pools = nil,
    ifcs_accs  = nil,
}

function SPC ()
    return string.rep(' ',_AST.iter()().depth*2)
end

function pred_sort (v1, v2)
    return (v1.len or _ENV.c.word.len) > (v2.len or _ENV.c.word.len)
end

F = {
    Root = function (me)

        local _defs  = {}   -- pool / struct / cstruct / host
        local _pools = {}   -- per-class pool (not per-block pool)
        local _accs  = {}   -- interfaces accessors

        -- Main.host must be before everything
        local _host = _ENV.clss.Main.host
        _ENV.clss.Main.host = ''

        for _,cls in ipairs(_ENV.clss) do
            local protos = ''
            for p in string.gmatch(cls.host, '(%w+ CEU_'..cls.id..'[^{;]*)') do
                protos = protos .. p .. ';\n'
            end

            if cls.is_ifc then
                _defs[#_defs+1] = 'typedef void CEU_'..cls.id..';'
                                    -- void* (no casts needed class=>interface)
            else
                _defs[#_defs+1] = 'typedef struct CEU_'..cls.id..
                                    ' CEU_'..cls.id..';'
            end
            _defs[#_defs+1] = protos
            _defs[#_defs+1] = table.concat(cls.ifc_accs_protos, '\n')
            _defs[#_defs+1] = cls.struct
            _defs[#_defs+1] = cls.cstruct
            _defs[#_defs+1] = cls.host

            _accs[#_accs+1] = table.concat(cls.ifc_accs_impls, '\n')

            if cls.max and _PROPS.has_news_pool then
                cls.pool = 'CEU_POOL_'..cls.id
                _defs[#_defs+1] = [[
CEU_POOL_DCL(]]..cls.pool..','..'CEU_'..cls.id..','..cls.max..[[);
]]
                _pools[#_pools+1] = [[
ceu_pool_init(&]]..cls.pool..', '..cls.max..', sizeof(CEU_'..cls.id..'), '
    ..'(char**)'..cls.pool..'_queue, (char*)'..cls.pool..[[_mem);
]]
            end
        end
        _MEM.clss_defs  = _host ..'\n'.. table.concat(_defs,'\n')
        _MEM.clss_pools = table.concat(_pools, '\n')
        _MEM.ifcs_accs  = table.concat(_accs,  '\n')
    end,

    Host = function (me)
        -- unescape `##´ => `#´
        local src = string.gsub(me[1], '^%s*##',  '#')
              src = string.gsub(src,   '\n%s*##', '\n#')
        CLS().host = CLS().host .. [[

#line ]]..me.ln[2]..' "'..me.ln[1]..[["
]] .. src
    end,


    Dcl_cls_pre = function (me)
        -- whole class
        me.struct = [[
struct CEU_]]..me.id..[[ {
  struct tceu_org org;
  tceu_trl trls_[ ]]..me.trails_n..[[ ];
]]

        -- only the constructor
        me.cstruct = [[
typedef struct {
]]
        me.host = ''

        -- field accessors
        me.ifc_accs_protos = {}
        me.ifc_accs_impls  = {}
        if me.is_ifc then
            for _,var in ipairs(me.blk_ifc.vars) do
                if not var.isEvt then   -- events cannot be accessed from C
                    var.ifc_acc = '_CEU_'..me.id..'_'..var.id
                               -- '_' to distingish from method prototypes
                    me.ifc_accs_protos[#me.ifc_accs_protos+1] =
                        _TP.c(var.tp)..'* '..var.ifc_acc..' ('.._TP.c(me.id)..'* org);'
                    me.ifc_accs_impls[#me.ifc_accs_impls+1] =
_TP.c(var.tp)..'* '..var.ifc_acc..[[(]].._TP.c(me.id)..[[* org) {
    return (]].._TP.c(var.tp)..[[*) (
        ((char*)org) + CEU.ifcs_flds[((tceu_org*)org)->cls][
            ]].._ENV.ifcs.flds[var.ifc_id]..[[
        ]
            );
}
]]
                end
            end
        end
    end,
    Dcl_cls_pos = function (me)
        me.cstruct = me.cstruct..'\n} T'.._TP.c(me.id)..';\n'
        if me.is_ifc then
            me.struct = ''--'typedef void '.._TP.c(me.id)..';\n'
--[[
            me.struct = 'typedef union {\n'
            for cls in pairs(me.matches) do
                me.struct = me.struct..'  '.._TP.c(cls.id)
                                ..'* __'..cls.id..';\n'
            end
            me.struct = me.struct..'} '.._TP.c(me.id)..';\n'
]]
            return
        end

        me.struct  = me.struct..'\n};\n'--.._TP.c(me.id)..';\n'
DBG('===', me.id, me.trails_n, '('..tostring(me.max)..')')
--DBG(me.struct)
--DBG('======================')
    end,

    Stmts_pre = function (me)
        local cls = CLS()
        cls.struct = cls.struct..SPC()..'union {\n'
    end,
    Stmts_pos = function (me)
        local cls = CLS()
        cls.struct = cls.struct..SPC()..'};\n'
    end,

    Block_pos = function (me)
        local cls = CLS()
        cls.struct = cls.struct..SPC()..'};\n'
    end,
    Block_pre = function (me)
        local cls = CLS()

        cls.struct = cls.struct..SPC()..'struct { /* BLOCK ln='..me.ln[2]..' */\n'

        if me.trl_orgs then
            cls.struct = cls.struct .. SPC()
                            ..'tceu_lnk __lnks_'..me.n..'[2];\n'
        end

        if me.fins then
            for i=1, #me.fins do
            cls.struct = cls.struct .. SPC()
                            ..'u8 __fin_'..me.n..'_'..i..': 1;\n'
            end
        end

        -- memory pools from spawn/new
        if me.pools then
            for node, n in pairs(me.pools) do
                node.pool = '__pool_'..node.n..'_'..node.cls.id
                cls.struct = cls.struct .. [[
CEU_POOL_DCL(]]..node.pool..', CEU_'..node.cls.id..','..n..[[)
]]
            end
        end

        for _, var in ipairs(me.vars) do
            local len
            --if var.isTmp or var.isEvt then  --
            if var.isTmp then --
                len = 0
            elseif var.isEvt then --
                len = 1   --
            elseif var.cls then
                len = 10    -- TODO: no static types
                --len = (var.arr or 1) * ?
            elseif var.arr then
                len = 10    -- TODO: no static types
--[[
                local _tp = _TP.deref(var.tp)
                len = var.arr * (_TP.deref(_tp) and _ENV.c.pointer.len
                             or (_ENV.c[_tp] and _ENV.c[_tp].len
                                 or _ENV.c.word.len)) -- defaults to word
]]
            elseif _TP.deref(var.tp) then
                len = _ENV.c.pointer.len
            else
                len = _ENV.c[var.tp].len
            end
            var.len = len
        end

        -- sort offsets in descending order to optimize alignment
        -- TODO: previous org metadata
        local sorted = { unpack(me.vars) }
        if me ~= CLS().blk_ifc then
            table.sort(sorted, pred_sort)   -- TCEU_X should respect lexical order
        end

        for _, var in ipairs(sorted) do
            if not var.isEvt then
                local tp = _TP.c(var.tp)
                local dcl = [[
#line ]]..var.ln[2]..' "'..var.ln[1]..[["
]]
                var.id_ = var.id ..
                            (var.inTop and '' or ('_'..var.n))
                if var.arr then
                    dcl = dcl .. _TP.deref(tp)..' '..var.id_..'['..var.arr.cval..']'
                else
                    dcl = dcl .. tp..' '..var.id_
                end
                cls.struct = cls.struct..SPC()..'  '..dcl..';\n'
                if me == CLS().blk_ifc then
                    cls.cstruct = cls.cstruct..SPC()..'  '..dcl..';\n'
                end
            end
        end
    end,

    ParOr_pre = function (me)
        local cls = CLS()
        cls.struct = cls.struct..SPC()..'struct {\n'
    end,
    ParOr_pos = function (me)
        local cls = CLS()
        cls.struct = cls.struct..SPC()..'};\n'
    end,
    ParAnd_pre = 'ParOr_pre',
    ParAnd_pos = 'ParOr_pos',
    ParEver_pre = 'ParOr_pre',
    ParEver_pos = 'ParOr_pos',

    ParAnd = function (me)
        local cls = CLS()
        for i=1, #me do
            cls.struct = cls.struct..SPC()..'u8 __and_'..me.n..'_'..i..': 1;\n'
        end
    end,

    AwaitT = function (me)
        local cls = CLS()
        cls.struct = cls.struct..SPC()..'s32 __wclk_'..me.n..';\n'
    end,

--[[
    AwaitS = function (me)
        for _, awt in ipairs(me) do
            if awt.isExp then
            elseif awt.tag=='Ext' then
            else
                awt.off = alloc(CLS().mem, 4)
            end
        end
    end,
]]

    Thread_pre = 'ParOr_pre',
    Thread = function (me)
        local cls = CLS()
        cls.struct = cls.struct..SPC()..'CEU_THREADS_T __thread_id_'..me.n..';\n'
        cls.struct = cls.struct..SPC()..'s8*       __thread_st_'..me.n..';\n'
    end,
    Thread_pos = 'ParOr_pos',
}

_AST.visit(F)

end

    
do
local t2n = {
     us = 10^0,
     ms = 10^3,
      s = 10^6,
    min = 60*10^6,
      h = 60*60*10^6,
}

local _ceu2c = { ['or']='||', ['and']='&&', ['not']='!' }
local function ceu2c (op)
    return _ceu2c[op] or op
end

function V (me)
    ASR(me.val, me, 'invalid expression')
    return me.val
end

function CUR (me, id)
    if id then
        return '(('.._TP.c(CLS().id)..'*)_ceu_org)->'..id
    else
        return '(('.._TP.c(CLS().id)..'*)_ceu_org)'
    end
end

F =
{
    Block_pre = function (me)
        local cls = CLS()
        for _, var in ipairs(me.vars) do
            if not var.isEvt then
                if var.isTmp then
                    var.val = '__ceu_'..var.id..'_'..var.n
                else
                    var.val = CUR(me, var.id_)
                end
            end
        end
        if me.trl_orgs then
            me.trl_orgs.val = CUR(me, '__lnks_'..me.n)
        end
        if me.fins then
            for i, fin in ipairs(me.fins) do
                fin.val = CUR(me, '__fin_'..me.n..'_'..i)
            end
        end
    end,

    ParAnd = function (me)
        me.val = CUR(me, '__and_'..me.n)
    end,

    Global = function (me)
        me.val = '&CEU.mem'
    end,

    This = function (me)
        if _AST.iter'Dcl_constr'() then
            me.val = '__org'    -- set when calling constr
        else
            me.val = '_ceu_org'
        end
        me.val = '(*(('.._TP.c(me.tp)..'*)'..me.val..'))'
    end,

    Var = function (me)
        me.val = me.var.val
    end,

    SetExp = function (me)
        local _, fr, to = unpack(me)
        V(fr)     -- error on reads of internal events
    end,

    SetVal = function (me)
        me.val = me.from.val
    end,
    New = function (me)
        me.val = '(('.._TP.c(me[2])..'*)__ceu_new)'
                                        -- defined by _New (code.lua)
    end,
    Spawn = function (me)
        me.val = '(__ceu_new != NULL)'
    end,
    Thread = function (me)
        me.thread_id = CUR(me, '__thread_id_'..me.n)
        me.thread_st = CUR(me, '__thread_st_'..me.n)
        me.val = '(*('..me.thread_st..') > 0)'
    end,

    EmitExt = function (me)
        local e1, e2 = unpack(me)
        if e1.evt.pre == 'input' then
            return
        end
        local len, val
        if e2 then
            local tp = _TP.deref(e1.evt.tp, true)
            if tp then
                len = 'sizeof('.._TP.c(tp)..')'
                val = V(e2)
            else
                len = 'sizeof('.._TP.c(e1.evt.tp)..')'
                val = V(e2)
            end
        else
            len = 0
            val = 'NULL'
        end
        me.val = '\n'..[[
#if defined(ceu_out_event_]]..e1.evt.id..[[)
    ceu_out_event_]]..e1.evt.id..'('..val..[[)
#elif defined(ceu_out_event)
    ceu_out_event(CEU_OUT_]]..e1.evt.id..','..len..','..val..[[)
#else
    0
#endif
]]
    end,

    AwaitInt = 'AwaitExt',
    AwaitExt = function (me)
        local e1 = unpack(me)
        if _TP.deref(e1.evt.tp) then
            me.val = '(('.._TP.c(e1.evt.tp)..')_ceu_evtp.ptr)'
        else
            me.val = '(_ceu_evtp.v)'
            --me.val = '*(('.._TP.c(e1.evt.tp)..'*)_ceu_evtp.ptr)'
        end
    end,
    AwaitT = function (me)
        me.val      = 'CEU.wclk_late'
        me.val_wclk = CUR(me, '__wclk_'..me.n)
    end,
--[[
    AwaitS = function (me)
        me.val = '__ceu_'..me.n..'_AwaitS'
    end,
]]

    Op2_call = function (me)
        local _, f, exps = unpack(me)
        local ps = {}
        for i, exp in ipairs(exps) do
            ps[i] = V(exp)
        end
        if f.org and string.sub(me.c.id,1,1)=='_' then
            local op = (_ENV.clss[f.org.tp].is_ifc and '') or '&'
            table.insert(ps, 1, op..V(f.org))   -- only native
                -- avoids this.f(), where f is a pointer to func
                -- vs this._f()
        end
        me.val = V(f)..'('..table.concat(ps,',')..')'
    end,

    Op2_idx = function (me)
        local _, arr, idx = unpack(me)
        me.val = V(arr)..'['..V(idx)..']'
    end,

    Op2_any = function (me)
        local op, e1, e2 = unpack(me)
        me.val = '('..V(e1)..ceu2c(op)..V(e2)..')'
    end,
    ['Op2_-']   = 'Op2_any',
    ['Op2_+']   = 'Op2_any',
    ['Op2_%']   = 'Op2_any',
    ['Op2_*']   = 'Op2_any',
    ['Op2_/']   = 'Op2_any',
    ['Op2_|']   = 'Op2_any',
    ['Op2_&']   = 'Op2_any',
    ['Op2_<<']  = 'Op2_any',
    ['Op2_>>']  = 'Op2_any',
    ['Op2_^']   = 'Op2_any',
    ['Op2_==']  = 'Op2_any',
    ['Op2_!=']  = 'Op2_any',
    ['Op2_>=']  = 'Op2_any',
    ['Op2_<=']  = 'Op2_any',
    ['Op2_>']   = 'Op2_any',
    ['Op2_<']   = 'Op2_any',
    ['Op2_or']  = 'Op2_any',
    ['Op2_and'] = 'Op2_any',

    Op1_any = function (me)
        local op, e1 = unpack(me)
        me.val = '('..ceu2c(op)..V(e1)..')'
    end,
    ['Op1_~']   = 'Op1_any',
    ['Op1_-']   = 'Op1_any',
    ['Op1_not'] = 'Op1_any',

    ['Op1_*'] = function (me)
        local op, e1 = unpack(me)
        local cls = _ENV.clss[_TP.deref(e1.tp)]
        if cls and cls.is_ifc then
            me.val = V(e1)
        else
            me.val = '('..ceu2c(op)..V(e1)..')'
        end
    end,
    ['Op1_&'] = function (me)
        local op, e1 = unpack(me)
        me.val = '('..ceu2c(op)..V(e1)..')'
    end,

    ['Op2_.'] = function (me)
        if me.org then
            local cls = _ENV.clss[me.org.tp]
            if cls and cls.is_ifc then
                if me.var.isEvt then
                    me.val = nil    -- cannot be used as variable
                    local org = '((tceu_org*)'..me.org.val..')'
                    me.evt_idx = '(CEU.ifcs_evts['..org..'->cls]['
                                    .._ENV.ifcs.evts[me.var.ifc_id]
                                ..'])'
                else    -- var
                    me.val = '(*('..me.var.ifc_acc..'('..me.org.val..')))'
                end
            else
                if me.c then
                    me.val = me.c.id_
                elseif me.var.isEvt then
                    me.val = nil    -- cannot be used as variable
                    me.org.val = '&'..me.org.val -- always via reference
                    me.evt_idx = me.var.evt_idx
                else    -- var
                    me.val = me.org.val..'.'..me.var.id_
                end
            end
        else
            local op, e1, id = unpack(me)
            me.val  = '('..V(e1)..ceu2c(op)..id..')'
        end
    end,

    Op1_cast = function (me)
        local tp, exp = unpack(me)
        local val = V(exp)

        local _tp = _TP.deref(tp)
        local cls = _tp and _ENV.clss[_tp]
        if cls then
            if cls.is_ifc then
                -- TODO: out of bounds acc
                val = '(('..val..' == NULL) ? NULL : '..
                        '((CEU.ifcs_clss[((tceu_org*)'..val..')->cls]'
                            ..'['..cls.n..']) ?'..val..' : NULL)'..
                      ')'
            else
                val = '(('..val..' == NULL) ? NULL : '..
                        '((((tceu_org*)'..val..')->cls == '..cls.n..') ? '
                        ..val..' : NULL)'..
                      ')'
            end
        end

        me.val = '(('.._TP.c(tp)..')'..val..')'
    end,

    WCLOCKK = function (me)
        local h,min,s,ms,us = unpack(me)
        me.us  = us*t2n.us + ms*t2n.ms + s*t2n.s + min*t2n.min + h*t2n.h
        me.val = me.us
        ASR(me.us>0 and me.us<=2000000000, me, 'constant is out of range')
    end,

    WCLOCKE = function (me)
        local exp, unit = unpack(me)
        me.us   = nil
        me.val  = V(exp) .. '*' .. t2n[unit]-- .. 'L'
    end,

    RawExp = function (me)
        me.val = unpack(me)

        -- handle org iterators
        local blk = _AST.iter'Do'()
        blk = blk and blk[1]
        if me.iter_ini then
            if blk.trl_orgs then
                me.val = [[
( (_ceu_org->trls[ ]]..blk.trl_orgs[1]..[[ ].lnks[0].nxt->n == 0) ?
    NULL :
    _ceu_org->trls[ ]]..blk.trl_orgs[1]..[[ ].lnks[0].nxt )
]]
            else
                me.val = 'NULL'
            end
        elseif me.iter_nxt then
            if blk.trl_orgs then
                local var = me.iter_nxt.var.val
                me.val = '(('..var..'->nxt->n==0) ? NULL : '..var..'->nxt)'
            else
                me.val = 'NULL'
            end
        end
    end,

    Nat = function (me)
        me.val = string.sub(me[1], 2)
    end,
    SIZEOF = function (me)
        --me.val = me.sval
        local tp = unpack(me)
        if type(tp) == 'string' then
            me.val = 'sizeof('.._TP.c(me[1])..')'
        else
            me.val = 'sizeof('..tp.val..')'
        end
    end,
    STRING = function (me)
        me.val = me[1]
    end,
    CONST = function (me)
        me.val = me[1]
    end,
    NULL = function (me)
        me.val = '((void *)0)'
    end,
}

_AST.visit(F)

end

    
do
_CODE = {
    has_goto = false,   -- avoids "unused label"
    threads = '',
}

function CONC_ALL (me, t)
    t = t or me
    for _, sub in ipairs(t) do
        if _AST.isNode(sub) then
            CONC(me, sub)
        end
    end
end

function CONC (me, sub, tab)
    sub = sub or me[1]
    tab = string.rep(' ', tab or 0)
    me.code = me.code .. string.gsub(sub.code, '(.-)\n', tab..'%1\n')
end

function ATTR (me, n1, n2)
    LINE(me, V(n1)..' = '..V(n2)..';')
end

function CASE (me, lbl)
    LINE(me, 'case '..lbl.id..':;', 0)
end

function DEBUG_TRAILS (me, lbl)
    LINE(me, [[
#ifdef CEU_DEBUG_TRAILS
fprintf(stderr, "\tOK!\n");
#endif
]])
end

function LINE (me, line, spc)
    spc = spc or 4
    spc = string.rep(' ', spc)
    me.code = me.code .. [[

#line ]]..me.ln[2]..' "'..me.ln[1]..[["
]] .. spc..line
end

function HALT (me, cond)
    if cond then
        LINE(me, 'if ('..cond..') {')
    end
    LINE(me, '\tgoto _CEU_NEXT_;')
    if cond then
        LINE(me, '}')
    end
end

function GOTO (me, lbl, org)
    _CODE.has_goto = true
    if org then
        LINE(me, [[
_ceu_org = ]]..org..[[;
]])
    end
    LINE(me, [[
_ceu_lbl = ]]..lbl.id..[[;
goto _CEU_GOTO_;
]])
end

function PAUSE (me, no)
    if not _PROPS.has_pses then
        return
    end

    for pse in _AST.iter'Pause' do
        COMM(me, 'PAUSE: '..pse.dcl.var.id)
        LINE(me, [[
if (]]..V(pse.dcl.var)..[[) {
]])
        if me.tag == 'AwaitInt' then
            LINE(me, [[
    _ceu_trl->stk = _ceu_seqno-1;   /* awake again */
]])
        end
        LINE(me, [[
    goto ]]..no..[[;
}
]])
    end
end

function COMM (me, comm)
    LINE(me, '/* '..comm..' */', 0)
end

local _iter = function (n)
    if n.tag == 'Block' and n.needs_clr then
        return true
    end

    if n.tag == 'SetBlock' and n.needs_clr then
        return true
    end

    if n.tag == 'Loop' and n.needs_clr then
        return true
    end

    n = n.__par
    if n and (n.tag == 'ParOr') then
        return true     -- par branch
    end
end

function CLEAR (me)
    COMM(me, 'CLEAR: '..me.tag..' ('..me.ln[2]..')')

    if not me.needs_clr then
        return
    end

    -- check if top will clear during same reaction
    if (not me.needs_clr_fin) and _ANA then   -- fin must execute before any stmt
        local top = _AST.iter(_iter)()
        if top and _ANA.CMP(top.ana.pos, me.ana.pos) then
            return  -- top will clear
        end
    end

    --LINE(me, 'ceu_trails_clr('..me.trails[1]..','..me.trails[2]..
                                --', _ceu_org);')

    LINE(me, [[
/* trails[1] points to ORG blk */
{
    tceu_trl* trl = &_ceu_org->trls[ ]]..me.trails[1]..[[ ];
    trl->evt = CEU_IN__STK;
    trl->stk = _ceu_stki;
    trl->lbl = ]]..me.lbl_clr.id..[[;
}
_CEU_STK[_ceu_stki  ].evtp = _ceu_evtp;
#ifdef CEU_INTS
#ifdef CEU_ORGS
_CEU_STK[_ceu_stki  ].evto = _ceu_evto;
#endif
#endif
_CEU_STK[_ceu_stki++].evt  = _ceu_evt;

/* [ trails[1]+1, trails[2] [ */
_ceu_trl  = &_ceu_org->trls[ ]]..(me.trails[1]+1)..[[ ];
                                /* trails[1]+1 is in */
_ceu_stop = &_ceu_org->trls[ ]]..(me.trails[2]+1)..[[ ];
                                /* trails[2]+1 is out */
_ceu_evt = CEU_IN__CLEAR;
goto _CEU_CALLTRL_;

case ]]..me.lbl_clr.id..[[:;
]])
end

F = {
    Node_pre = function (me)
        me.code = ''
    end,

    Do         = CONC_ALL,
    Finally    = CONC_ALL,
    Dcl_constr = CONC_ALL,

    Stmts = function (me)
        LINE(me, '{')   -- allows C declarations for New/Spawn
        CONC_ALL(me)
        LINE(me, '}')
    end,

    Root = function (me)
        for _, cls in ipairs(_ENV.clss_cls) do
            CONC(me, cls)
        end
    end,

    BlockI = CONC_ALL,
    BlockI_pos = function (me)
        me.code_ifc = me.code       -- see Dcl_cls
        me.code = ''                -- avoid this code
    end,

    Dcl_cls = function (me)
        if me.is_ifc then
            CONC_ALL(me)
            return
        end

        -- copy all method pointers
        local fs = ''
        for id, t in pairs(me.c) do
            -- "ifc_type = cls_type" (src is an interface method)
            fs = fs ..  CUR(me,id)..' = ('.._TP.c(me.blk_ifc.vars[id].tp)..')'
                                          ..'&CEU_'..me.id..'_'..id..';\n'
        end

        if me.has_pre then
            CASE(me, me.lbl_pre)
            LINE(me, fs)    -- method pointers
                fs = ''     -- clear
            me.code = me.code .. me.blk_ifc.code_pre
            LINE(me, me.blk_ifc[1][1].code_ifc)   -- Block->Stmts->BlockI
            HALT(me)
        end

        CASE(me, me.lbl)
        LINE(me, fs)    -- method pointers
            fs = ''     -- clear

        -- TODO: move to _ORG? (_MAIN does not call _ORG)
        LINE(me, [[
#ifdef CEU_IFCS
_ceu_org->cls = ]]..me.n..[[;
#endif
]])

        CONC_ALL(me)

-- TODO(rom): avoid clss w/o new
        --if i_am_instantiable then
            LINE(me, [[
#ifdef CEU_NEWS
if (_ceu_org->isSpw) {
]])
            F.Free(me)
            LINE(me, [[
}
#endif
]])
        --end

        if not (_ANA and me.ana.pos[false]) then
            HALT(me)
        end
    end,

    -- TODO: C function?
    _ORG = function (me, t)
        COMM(me, 'start org: '..t.id)

        --[[
class T with
    <PRE>           -- 1    me.lbls_pre[i].id
    var int v = 0;
do
    <BODY>          -- 3    me.lbls_body[i].id
end

<...>               -- 0

var T t with
    <CONSTR>        -- 2    no lbl (cannot call anything)
end;

<CONT>              -- 4    me.lbls_cnt[i].id
]]

        -- each org has its own trail on enclosing block
        for i=1, (t.arr and t.arr.sval or 1) do
            local org = t.arr and
                '((tceu_org*) '..t.val..'['..(i-1)..']'..')'
            or
                '((tceu_org*) '..t.val..')'
            LINE(me, [[
#ifdef CEU_NEWS
    ]]..org..[[->isDyn  = ]]..t.isDyn..[[;
    ]]..org..[[->isSpw  = ]]..t.isSpw..[[;
#endif

    /* resets org memory and starts org.trail[0]=Class_XXX */
    ceu_org_init(]]..org..[[, ]]
                ..t.cls.trails_n..','
                ..(t.cls.has_pre and t.cls.lbl_pre.id or t.cls.lbl.id)..[[,
                _ceu_stki+1,    /* run now */
                _ceu_org, ]]..t.par_trl_idx..[[);
]])

            if t.cls.has_pre then
                LINE(me, [[
    /* hold current blk trail: set to my continuation */
    _ceu_trl->evt = CEU_IN__STK;
    _ceu_trl->lbl = ]]..me.lbls_pre[i].id..[[;
    _ceu_trl->stk = _ceu_stki;
    _CEU_STK[_ceu_stki  ].evtp = _ceu_evtp;
#ifdef CEU_INTS
#ifdef CEU_ORGS
    _CEU_STK[_ceu_stki  ].evto = _ceu_evto;
#endif
#endif
    _CEU_STK[_ceu_stki++].evt  = _ceu_evt;

    /* switch to ORG for PRE */
    _ceu_org  = ]]..org..[[;
    _ceu_stop = &_ceu_org->trls[_ceu_org->n]; /* don't follow the up link */
    goto _CEU_CALL_;

case ]]..me.lbls_pre[i].id..[[:;
    /* BACK FROM PRE */
]])
            end
            if t.constr then
                LINE(me, '{ tceu_org* __org = '..org..';')
                CONC(me, t.constr)      -- constructor before executing
                LINE(me, '}')
            end
            LINE(me, [[
    /* hold current blk trail: set to my continuation */
    _ceu_trl->evt = CEU_IN__STK;
    _ceu_trl->lbl = ]]..me.lbls_cnt[i].id..[[;
    _ceu_trl->stk = _ceu_stki;

    _CEU_STK[_ceu_stki  ].evtp = _ceu_evtp;
#ifdef CEU_INTS
#ifdef CEU_ORGS
    _CEU_STK[_ceu_stki  ].evto = _ceu_evto;
#endif
#endif
    _CEU_STK[_ceu_stki++].evt  = _ceu_evt;

    /* switch to ORG */

    ]]..org..[[->trls[0].evt = CEU_IN__STK;
    ]]..org..[[->trls[0].lbl = ]]..t.cls.lbl.id..[[;
    ]]..org..[[->trls[0].stk = _ceu_stki;

    _ceu_org  = ]]..org..[[;
    _ceu_stop = &_ceu_org->trls[_ceu_org->n]; /* don't follow the up link */
    goto _CEU_CALL_;

case ]]..me.lbls_cnt[i].id..[[:;
]])
        end
    end,

    Dcl_var = function (me)
        local _,_,_,_,constr = unpack(me)
        local var = me.var
        if not var.cls then
            return
        end

        F._ORG(me, {
            id      = var.id,
            isDyn   = 0,
            isSpw   = 0,
            cls     = var.cls,
            val     = '&'..var.val,
            constr  = constr,
            arr     = var.arr,
            par_trl_idx = var.blk.trl_orgs[1],
        })
    end,

    _New = function (me, t)
        if not me.setto then
            LINE(me, '{')   -- otherwise Stmts create the block
        end
        LINE(me, [[
    tceu_org* __ceu_new;
]])
        if t.pool then
            LINE(me, [[
    __ceu_new = (tceu_org*) ceu_pool_alloc(&]]..t.pool..[[);
]])
        else
            LINE(me, [[
    __ceu_new = (tceu_org*) malloc(sizeof(]].._TP.c(t.cls.id)..[[));
]])
        end

        LINE(me, [[
/*fprintf(stderr, "MALLOC: %p\n", __ceu_new); */
#ifdef CEU_RUNTESTS
    if (__ceu_new != NULL) {
        _ceu_dyns_++;
        if (_ceu_dyns_ > CEU_MAX_DYNS) {
            free(__ceu_new);
            __ceu_new = NULL;
            _ceu_dyns_--;
        }
    }
#endif
]])

        LINE(me, [[
    if (__ceu_new != NULL) {
]])
        if t.pool then
            LINE(me, '__ceu_new->pool = &'..t.pool..';')
        elseif _PROPS.has_news_pool then
            LINE(me, '__ceu_new->pool = NULL;')
        end
        F._ORG(me, {
            id      = 'dyn',
            isDyn   = 1,
            isSpw   = t.isSpw,
            cls     = t.cls,
            val     = '__ceu_new',
            constr  = t.constr,
            arr     = false,
            par_trl_idx = me.blk.trl_orgs[1],
        })
        LINE(me, [[
    }
]])
        if not me.setto then
            LINE(me, '}')   -- otherwise Stmts create the block
        end
    end,

    New = function (me)
        local max, id, constr = unpack(me)
        F._New(me, {
            cls     = me.cls,
            isSpw   = 0,
            pool    = me.pool and CUR(me,me.pool)
                        or me.cls.pool,
            constr  = constr,
        })
    end,

    Spawn = function (me)
        local max, id, constr = unpack(me)
        F._New(me, {
            cls     = me.cls,
            isSpw   = 1,
            pool    = me.pool and CUR(me,me.pool)
                        or me.cls.pool,
            constr  = constr,
        })
    end,

    Free = function (me)
        local exp = unpack(me)

        local cls, val
        if me.tag == 'Free' then
            cls = me.cls
            val = V(exp)
        else    -- Dcl_cls
            cls = me
            val = '_ceu_org'
        end

        local lbls = table.concat(cls.lbls,',')
        LINE(me, [[
{
    tceu_org* __ceu_tofree = (tceu_org*) ]]..val..[[;
    if (__ceu_tofree != NULL)
    {
        /* TODO: assert isDyn */
]])

        if me.tag == 'Free' then
            -- only if freeing someone else
            LINE(me, [[
        /* save my continuation */
        _ceu_trl->evt = CEU_IN__STK;
        _ceu_trl->stk = _ceu_stki;
        _ceu_trl->lbl = ]]..me.lbl_clr.id..[[;
]])
        end

        LINE(me, [[
        /* clear all __ceu_tofree [ trls[0], ... [ */
        /* this will call free() */
        _ceu_stop = __ceu_tofree;
        _ceu_trl  = &__ceu_tofree->trls[0];
]])
        if me.tag == 'Free' then    -- (or __ceu_tofree is already me)
            LINE(me, [[
        _ceu_org  = __ceu_tofree;
]])
        end
        LINE(me, [[
        _CEU_STK[_ceu_stki  ].evtp = _ceu_evtp;
#ifdef CEU_INTS
#ifdef CEU_ORGS
        _CEU_STK[_ceu_stki  ].evto = _ceu_evto;
#endif
#endif
        _CEU_STK[_ceu_stki++].evt  = _ceu_evt;

        _ceu_evt = CEU_IN__CLEAR;
        goto _CEU_CALLTRL_;
    }
}
case ]]..me.lbl_clr.id..[[:;
]])
    end,

    Block_pre = function (me)
        local cls = CLS()
        if cls.is_ifc then
            return
        end

        if me.trl_orgs then
            LINE(me, [[
_ceu_org->trls[ ]]..me.trl_orgs[1]..[[ ].evt  = CEU_IN__ORG;
_ceu_org->trls[ ]]..me.trl_orgs[1]..[[ ].lnks =
    (tceu_lnk*) &]]..me.trl_orgs.val..[[;

]]..me.trl_orgs.val..'[0].nxt = (tceu_org*) &'..me.trl_orgs.val..'[1]'..[[;

]]..me.trl_orgs.val..'[1].prv = (tceu_org*) &'..me.trl_orgs.val..'[0]'..[[;
]]..me.trl_orgs.val..'[1].nxt =  '..[[_ceu_org;
]]..me.trl_orgs.val..'[1].n   =  '..[[0;
]]..me.trl_orgs.val..'[1].lnk =  '..me.trl_orgs[1]..[[+1;
]])
        end

        if me.fins then
            LINE(me, [[
/*  FINALIZE */
_ceu_org->trls[ ]]..me.trl_fins[1]..[[ ].evt = CEU_IN__CLEAR;
_ceu_org->trls[ ]]..me.trl_fins[1]..[[ ].lbl = ]]..me.lbl_fin.id..[[;
_ceu_org->trls[ ]]..me.trl_fins[1]..[[ ].stk = _ceu_seqno-1;    /* awake now */
]])
            for _, fin in ipairs(me.fins) do
                LINE(me, fin.val..' = 0;')
            end
        end

        -- initialize pools for new/spawn
        if me.pools then
            for node, n in pairs(me.pools) do
                local pre = CUR(me,node.pool)
                LINE(me, [[
ceu_pool_init(&]]..pre..', '..n..', sizeof(CEU_'..node.cls.id..'), '
    ..'(char**)'..pre..'_queue, (char*)'..pre..[[_mem);
]])
            end
        end

        -- above code must execute before PRE
        if cls.has_pre and cls.blk_ifc==me then
            me.code_pre = me.code
            me.code = ''
        end

        -- declare tmps
        LINE(me, '{')       -- close in Block_pos
        for _, var in ipairs(me.vars) do
            if var.isTmp then
                if var.arr then
                    LINE(me, _TP.c(_TP.deref(var.tp))
                            ..' '..V(var)..'['..V(var.arr)..'];')
                else
                    LINE(me, _TP.c(var.tp)..' '..V(var)..';')
                end
            end
        end
    end,

    Block_pos = function (me)
        local stmts = unpack(me)
        if CLS().is_ifc then
            return
        end

-- TODO: try to remove this need
        if me.trails[1] ~= stmts.trails[1] then
            LINE(me, [[
/* switch to blk trail */
_ceu_trl = &_ceu_org->trls[ ]]..stmts.trails[1]..[[ ];
]])
        end
        CONC(me, blk)

        if me.fins then
            GOTO(me, me.lbl_fin_cnt)
            CASE(me, me.lbl_fin)
            for i, fin in ipairs(me.fins) do
                LINE(me, [[
if (]]..fin.val..[[) {
]] .. fin.code .. [[
}
]])
            end
            HALT(me)
            CASE(me, me.lbl_fin_cnt)
        end
        CLEAR(me)
        LINE(me, '}')       -- open in Block_pre

-- TODO: remove!
        if not (_ANA and me.ana.pos[false]) then
            LINE(me, [[
/* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_trl = &_ceu_org->trls[ ]]..me.trails[1]..[[ ]; */
]])
        end
    end,

    Pause = CONC_ALL,
-- TODO: meaningful name
    PauseX = function (me)
        local psed = unpack(me)
        LINE(me, [[
ceu_pause(&_ceu_org->trls[ ]]..me.blk.trails[1]..[[ ],
          &_ceu_org->trls[ ]]..me.blk.trails[2]..[[ ],
        ]]..psed..[[);
]])
    end,

    -- TODO: more tests
    Op2_call_pre = function (me)
        local _, f, exps, fin = unpack(me)
        if fin and fin.active then
            LINE(_AST.iter'Stmts'(), fin.val..' = 1;  /* XXX */')
        end
    end,
    Finalize = function (me)
        -- enable finalize
        local set,fin = unpack(me)
        if fin.active then
            LINE(me, fin.val..' = 1;')
        end
        if set then
            CONC(me, set)
        end
    end,

    SetExp = function (me)
        local _, fr, to, fin = unpack(me)
        COMM(me, 'SET: '..tostring(to[1]))    -- Var or C
        ATTR(me, to, fr)
        if to.tag=='Var' and to.var.id=='_ret' then
            LINE(me, [[
#ifdef ceu_out_end
    ceu_out_end(]]..V(to)..[[);
#endif
]])
        end

        -- enable finalize
        if fin and fin.active then
            LINE(me, fin.val..' = 1;')
        end
    end,

    SetBlock_pos = function (me)
        local blk,_ = unpack(me)
        CONC(me, blk)
        HALT(me)        -- must escape with `return´
        CASE(me, me.lbl_out)
        if me.has_return then
            CLEAR(me)
            LINE(me, [[
/* switch to 1st trail */
/* TODO: only if not joining with outer prio */
_ceu_trl = &_ceu_org->trls[ ]] ..me.trails[1]..[[ ];
]])
        end
    end,
    Return = function (me)
        GOTO(me, _AST.iter'SetBlock'().lbl_out)
    end,

    _Par = function (me)
        -- Ever/Or/And spawn subs
        COMM(me, me.tag..': spawn subs')
        for i, sub in ipairs(me) do
            if i > 1 then
                LINE(me, [[
{
    tceu_trl* trl = &_ceu_org->trls[ ]]..sub.trails[1]..[[ ];
    trl->evt = CEU_IN__STK;
    trl->lbl = ]]..me.lbls_in[i].id..[[;
    trl->stk = _ceu_stki;
}
]])
            end
        end
    end,

    ParEver = function (me)
        F._Par(me)
        for i, sub in ipairs(me) do
            if i > 1 then
                CASE(me, me.lbls_in[i])
            end
            CONC(me, sub)

            -- only if trail terminates
            if not sub.ana.pos[false] then
                HALT(me)
            end
        end
    end,

    ParOr_pos = function (me)
        F._Par(me)
        for i, sub in ipairs(me) do
            if i > 1 then
                CASE(me, me.lbls_in[i])
            end
            CONC(me, sub)

            if not (_ANA and sub.ana.pos[false]) then
                COMM(me, 'PAROR JOIN')
                GOTO(me, me.lbl_out)
            end
        end

        if not (_ANA and me.ana.pos[false]) then
            CASE(me, me.lbl_out)
            CLEAR(me)
            LINE(me, [[
/* switch to 1st trail */
/* TODO: only if not joining with outer prio */
_ceu_trl = &_ceu_org->trls[ ]]..me.trails[1]..[[ ];
]])
        end
    end,

    ParAnd = function (me)
        -- close AND gates
        COMM(me, 'close ParAnd gates')

        for i=1, #me do
            LINE(me, V(me)..'_'..i..' = 0;')
        end

        F._Par(me)

        for i, sub in ipairs(me) do
            if i > 1 then
                CASE(me, me.lbls_in[i])
            end
            CONC(me, sub)
            LINE(me, V(me)..'_'..i..' = 1;')
            GOTO(me, me.lbl_tst)
        end

        -- AFTER code :: test gates
        CASE(me, me.lbl_tst)
        for i, sub in ipairs(me) do
            HALT(me, '!'..V(me)..'_'..i)
        end

        LINE(me, [[
/* switch to 1st trail */
/* TODO: only if not joining with outer prio */
_ceu_trl = &_ceu_org->trls[ ]]..me.trails[1]..[[ ];
]])
    end,

    If = function (me)
        local c, t, f = unpack(me)
        -- TODO: If cond assert(c==ptr or int)

        LINE(me, [[
if (]]..V(c)..[[) {
]]    ..t.code..[[
} else {
]]    ..f.code..[[
}
]])
    end,

    Loop_pos = function (me)
        local body = unpack(me)

        LINE(me, [[
for (;;) {
]])
        CONC(me)
        local async = _AST.iter'Async'()
        if async then
            LINE(me, [[
#ifdef ceu_out_pending
    if (ceu_out_pending()) {
#else
    {
#endif
        _ceu_trl->evt = CEU_IN__ASYNC;
        _ceu_trl->lbl = ]]..me.lbl_asy.id..[[;
#ifdef ceu_out_async
        ceu_out_async(1);
#endif
]])
            HALT(me)
            LINE(me, [[
    }
    case ]]..me.lbl_asy.id..[[:;
]])
        end
        LINE(me, [[
}
]])
        if me.has_break and (not _AST.iter(_AST.pred_async)()) then
            CLEAR(me)
            LINE(me, [[
/* switch to 1st trail */
/* TODO: only if not joining with outer prio */
_ceu_trl = &_ceu_org->trls[ ]]..me.trails[1]..[[ ];
]])
        end
    end,

    Break = function (me)
        LINE(me, 'break;')
    end,

    CallStmt = function (me)
        local call = unpack(me)
        LINE(me, V(call)..';')
    end,

    EmitExt = function (me)
        local e1, e2 = unpack(me)
        local evt = e1.evt

        if evt.pre == 'output' then  -- e1 not Exp
            LINE(me, V(me)..';')
            return
        end

        assert(evt.pre == 'input')

        -- only async's need to split in two (to avoid stack growth)
        if _AST.iter'Async'() then
            LINE(me, [[
_ceu_trl->evt = CEU_IN__ASYNC;
_ceu_trl->lbl = ]]..me.lbl_cnt.id..[[;
#ifdef ceu_out_async
ceu_out_async(1);
#endif
]])
        end

        local emit
        if e2 then
            emit = 'ceu_go_event(CEU_IN_'..evt.id ..', (void*)'..V(e2)..');'
        else
            emit = 'ceu_go_event(CEU_IN_'..evt.id ..', NULL);'
        end

        if _AST.iter'Async'() then
            LINE(me, emit)
            HALT(me)
            LINE(me, [[
case ]]..me.lbl_cnt.id..[[:;
]])
        else
            -- called from Thread
            LINE(me, 'CEU_ATOMIC('..emit..')')
        end
    end,

    EmitT = function (me)
        local exp = unpack(me)

        -- only async's need to split in two (to avoid stack growth)
        if _AST.iter'Async'() then
            LINE(me, [[
_ceu_trl->evt = CEU_IN__ASYNC;
_ceu_trl->lbl = ]]..me.lbl_cnt.id..[[;
]])
        end

        local emit = [[
ceu_go_wclock((s32)]]..V(exp)..[[);     \
while (CEU.wclk_min <= 0) {             \
    ceu_go_wclock(0);                   \
}
]]
        if _AST.iter'Thread'() then
            emit = 'CEU_ATOMIC( '..emit..' )\n'
        end

        LINE(me, [[
#ifdef CEU_WCLOCKS
    ]]..emit..[[
#endif
]])

        if _AST.iter'Async'() then
            HALT(me)
            LINE(me, [[
case ]]..me.lbl_cnt.id..[[:;
]])
        end
    end,

    EmitInt = function (me)
        local int, exp = unpack(me)

        -- [ ... | me=stk | ... | oth=stk ]
        LINE(me, [[
_CEU_STK[_ceu_stki].evtp = _ceu_evtp;
#ifdef CEU_INTS
#ifdef CEU_ORGS
_CEU_STK[_ceu_stki].evto = _ceu_evto;
#endif
#endif
_CEU_STK[_ceu_stki].evt  = _ceu_evt;        /* 3nd (stk) other trails */

_ceu_trl->evt = CEU_IN__STK;
_ceu_trl->stk = _ceu_stki++;                /* 2nd (stk) me */
_ceu_trl->lbl = ]]..me.lbl_cnt.id..[[;
                                            /* 1st (stk+1) my lsts */
/* TRIGGER EVENT */
_ceu_evt  = ]]..(int.evt_idx or int.evt.evt_idx)..[[;
#ifdef CEU_ORGS
_ceu_evto = (tceu_org*) ]]..((int.org and int.org.val) or '_ceu_org')..[[;
#endif
]])
        if exp then
            local field = _TP.deref(exp.tp) and 'ptr' or 'v'
            LINE(me, [[
_ceu_evtp.]]..field..' = '..V(exp)..[[;
]])
        end
        LINE(me, [[
#ifdef CEU_ORGS
_ceu_org = (tceu_org*) &CEU.mem;   /* TODO(speed): check if is_ifc */
#endif
goto _CEU_CALL_;

case ]]..me.lbl_cnt.id..[[:;
]])
    end,

    AwaitN = function (me)
        HALT(me)
    end,

    AwaitT = function (me)
        local exp = unpack(me)
        local no = '_CEU_NO_'..me.n..'_'

        LINE(me, [[
ceu_trails_set_wclock(&]]..me.val_wclk..[[, (s32)]]..V(exp)..[[);
]]..no..[[:
    _ceu_trl->evt = CEU_IN__WCLOCK;
    _ceu_trl->lbl = ]]..me.lbl.id..[[;
]])
        HALT(me)

        LINE(me, [[
case ]]..me.lbl.id..[[:;
]])

        PAUSE(me, no)
        LINE(me, [[
    if (!ceu_wclocks_expired(&]]..me.val_wclk..[[, _ceu_evtp.dt) )
        goto ]]..no..[[;
]])
        DEBUG_TRAILS(me)
    end,

    AwaitInt = function (me)
        local int = unpack(me)
        local org = (int.org and int.org.val) or '_ceu_org'
        local no = '_CEU_NO_'..me.n..'_'

        LINE(me, [[
]]..no..[[:
    _ceu_trl->evt = ]]..(int.evt_idx or int.evt.evt_idx)..[[;
    _ceu_trl->lbl = ]]..me.lbl.id..[[;
]])
        -- awake in the same reaction (first awaits of a class)
--[=[
        if (not _AST.iter'Loop'()) and CLS().id~='Main' then
            LINE(me, [[
    _ceu_trl->stk = _ceu_seqno-1;
]])
        end
]=]
        HALT(me)

        LINE(me, [[
case ]]..me.lbl.id..[[:;
]])
        LINE(me, [[
#ifdef CEU_ORGS
    if ((tceu_org*)]]..org..[[ != _ceu_evto) {
        _ceu_trl->stk = _ceu_seqno-1;   /* awake again */
        goto ]]..no..[[;
    }
#endif
]])
        PAUSE(me, no)
        DEBUG_TRAILS(me)
    end,

    AwaitExt = function (me)
        local e = unpack(me)
        local no = _AST.iter'Pause'() and '_CEU_NO_'..me.n..'_:'
                    or ''
        LINE(me, [[
]]..no..[[
    _ceu_trl->evt = CEU_IN_]]..e.evt.id..[[;
    _ceu_trl->lbl = ]]..me.lbl.id..[[;
]])
        HALT(me)

        LINE(me, [[
case ]]..me.lbl.id..[[:;
]])
        PAUSE(me, string.sub(no,1,-2))  -- remove `:´
        DEBUG_TRAILS(me)
    end,

    AwaitS = function (me)
error'AwaitInt que falha tem que setar stk=MAX'
        local LBL_OUT = '__CEU_'..me.n..'_AWAITS'
        local set = _AST.iter'SetAwait'()

        for _, awt in ipairs(me) do
            if awt.tag=='WCLOCKK' or awt.tag=='WCLOCKE' then
                LINE(me, [[
ceu_trails_set_wclock(PTR_cur(u32*,]]..awt.off..'),(s32)'..V(awt)..[[);
]])
            end
        end

        local no = '_CEU_NO_'..me.n..'_'
        LINE(me, [[
]]..no..[[:
    _ceu_trl->evt = CEU_IN__ANY;
    _ceu_trl->lbl = ]]..me.lbl.id..[[;
]])
        HALT(me)

        LINE(me, [[
case ]]..me.lbl.id..[[:;
]])

        PAUSE(me, no)
        if set then
            LINE(me, '{ int __ceu_'..me.n..'_AwaitS;')
        end
        for i, awt in ipairs(me) do
            if awt.tag == 'Ext' then
                LINE(me, [[
                    if (_ceu_evt == CEU_IN_]]..awt.evt.id..[[) {
                ]])
            elseif awt.isExp then
                local org = (awt.org and awt.org.val) or '_ceu_org'
                LINE(me, [[
                    if ( (_ceu_evt == ]]..(awt.off or awt.evt.off)..[[)
                    #ifdef CEU_ORGS
                        && (]]..org..[[ != _ceu_evtp.org)
                    #endif
                    ) {
                ]])
            else -- WCLOCK
                LINE(me, [[
                    if ( (_ceu_evt == CEU_IN__WCLOCK)
                    &&   (!ceu_wclocks_not(PTR_cur(s32*,]]..awt.off..
                            [[), _ceu_evtp.dt)) ) {
                ]])
            end
            if set then
                LINE(me, V(me)..' = '..(i-1)..';')
            end
            LINE(me, 'goto '..LBL_OUT..';}')    -- close my if
        end

        HALT(me)
        LINE(me, LBL_OUT..':;')
        DEBUG_TRAILS(me)
        F._SetAwait(me)
        if set then
            LINE(me, '}')
        end
    end,

    Async = function (me)
        local vars,blk = unpack(me)
        for _, n in ipairs(vars) do
            ATTR(me, n.new, n.var)
        end
        LINE(me, [[
_ceu_trl->evt = CEU_IN__ASYNC;
_ceu_trl->lbl = ]]..me.lbl.id..[[;
#ifdef ceu_out_async
ceu_out_async(1);
#endif
]])
        HALT(me)

        LINE(me, [[
case ]]..me.lbl.id..[[:;
]])
        CONC(me, blk)
    end,

    SetThread = CONC,

    Thread_pre = function (me)
        me.lbl_out = '_CEU_THREAD_OUT_'..me.n
    end,

    Thread = function (me)
        local vars,blk = unpack(me)
        for _, n in ipairs(vars) do
            ATTR(me, n.new, n.var)      -- copy async parameters
        end

        -- spawn thread
        LINE(me, [[
]]..me.thread_st..[[  = malloc(sizeof(s8));
*]]..me.thread_st..[[ = 0;  /* ini */
{
    tceu_threads_p p = { _ceu_org, ]]..me.thread_st..[[ };
    int ret =
        CEU_THREADS_CREATE(&]]..me.thread_id..[[, _ceu_thread_]]..me.n..[[, &p);
    if (ret == 0)
    {
        assert( CEU_THREADS_DETACH(]]..me.thread_id..[[) == 0 );

        /* wait for "p" to be copied inside the thread */
        CEU_THREADS_MUTEX_UNLOCK(&CEU.threads_mutex);

        while (1) {
            CEU_THREADS_MUTEX_LOCK(&CEU.threads_mutex);
            int ok = (*(p.st) >= 1);   /* cpy ok? */
            if (ok)
                break;
            CEU_THREADS_MUTEX_UNLOCK(&CEU.threads_mutex);
        }

        /* proceed with sync execution (already locked) */
        *(p.st) = 2;    /* lck: now thread may also execute */
]])

        -- await termination
        local no = '_CEU_NO_'..me.n..'_'
        LINE(me, [[
]]..no..[[:
        _ceu_trl->evt = CEU_IN__THREAD;
        _ceu_trl->lbl = ]]..me.lbl.id..[[;
]])
        HALT(me)

        -- continue
        LINE(me, [[
case ]]..me.lbl.id..[[:;
        if (_ceu_evtp.thread != ]]..me.thread_id..[[) {
            goto ]]..no..[[; /* another thread is terminating: await again */
        }
    }
}
]])
        DEBUG_TRAILS(me)

        -- thread function
        local tp = _TP.c(CLS().id)
        _CODE.threads = _CODE.threads .. [[
void* _ceu_thread_]]..me.n..[[ (void* __ceu_p)
{
    /* start thread */

    /* copy param */
    tceu_threads_p _ceu_p = *((tceu_threads_p*) __ceu_p);
    tceu_org* _ceu_org = _ceu_p.org;

    /* now safe for sync to proceed */
    CEU_THREADS_MUTEX_LOCK(&CEU.threads_mutex);
    *(_ceu_p.st) = 1;
    CEU_THREADS_MUTEX_UNLOCK(&CEU.threads_mutex);

    /* ensures that sync reaquires the mutex and terminates
     * the current reaction before I proceed
     * otherwise I could lock below and reenter sync
     */
    while (1) {
        CEU_THREADS_MUTEX_LOCK(&CEU.threads_mutex);
        int ok = (*(_ceu_p.st) >= 2);   /* lck ok? */
        CEU_THREADS_MUTEX_UNLOCK(&CEU.threads_mutex);
        if (ok)
            break;
    }

    /* body */
    ]]..blk.code..[[

    /* goto from "sync" and already terminated */
    ]]..me.lbl_out..[[:

    /* terminate thread */
    {
        tceu_evtp evtp;
        evtp.thread = CEU_THREADS_SELF();
        /*pthread_testcancel();*/
        CEU_THREADS_MUTEX_LOCK(&CEU.threads_mutex);
    /* only if sync is not active */
        if (*(_ceu_p.st) < 3) {             /* 3=end */
            *(_ceu_p.st) = 3;
            ceu_go(CEU_IN__THREAD, evtp);   /* keep locked */
        } else {
            free(_ceu_p.st);                /* fin finished, I free */
        }
        CEU_THREADS_MUTEX_UNLOCK(&CEU.threads_mutex);
    }

    /* more correct would be two signals:
     * (1) above, when I finish
     * (2) finalizer, when sync finishes
     * now the program may hang if I never reach here
     */
    CEU_THREADS_COND_SIGNAL(&CEU.threads_cond);
    return NULL;
}
]]
    end,

    RawStmt = function (me)
        if me.thread then
            me[1] = [[
if (*]]..me.thread.thread_st..[[ < 3) {     /* 3=end */
    *]]..me.thread.thread_st..[[ = 3;
    /*assert( pthread_cancel(]]..me.thread.thread_id..[[) == 0 );*/
} else {
    free(]]..me.thread.thread_st..[[);      /* thr finished, I free */
}
]]
        end

        LINE(me, me[1])
    end,

    Sync = function (me)
        local thr = _AST.iter'Thread'()
        LINE(me, [[
CEU_THREADS_MUTEX_LOCK(&CEU.threads_mutex);
if (*(_ceu_p.st) == 3) {        /* 3=end */
    CEU_THREADS_MUTEX_UNLOCK(&CEU.threads_mutex);
    goto ]]..thr.lbl_out..[[;   /* exit if ended from "sync" */
} else {                        /* othrewise, execute block */
]])
        CONC(me)
        LINE(me, [[
    CEU_THREADS_MUTEX_UNLOCK(&CEU.threads_mutex);
}
]])
    end,
}

_AST.visit(F)

end

end

local tps = { [0]='void', [1]='8', [2]='16', [4]='32' }

-- TEMPLATE
local tpl
do
    tpl = [===[#line 1 "=== FILENAME ==="

=== DEFS ===

/* Order of C definitions:
=== DEFS
    -- external:
    CEU_IN_*
    CEU_OUT_*
    CEU_OUT_n
    CEU_FUN_*

    -- ifdefs 1:
    CEU_EXTS CEU_WCLOCKS CEU_INTS CEU_ASYNCS CEU_THREADS CEU_ORGS
    CEU_NEWS CEU_NEWS_POOL CEU_NEWS_MALLOC CEU_IFCS CEU_CLEAR CEU_PSES

    -- ifdefs 2:
    CEU_GOTO CEU_RUNTESTS

    -- tuples:
    typedef struct {
            void* _1;
            void* _2;
    } tceu__int___TCEU_Transaction_;

=== POOL_C

CEU_WCLOCK_INACTIVE
CEU_WCLOCK_EXPIRED

CEU_NMEM
CEU_NTRAILS
CEU_NCLS

CEU_THREADS_*
CEU_ATOMIC

-- limits
    tceu_nevt
    tceu_nlbl
    tceu_ncls
    CEU_MAX_STACK

-- types
    tceu_trl
    tceu_evtp
    tceu_stk
    tceu_lst
    tceu_lnk
    tceu_org

=== CLSS_DEFS
    - main host
    - clss
        - "typedef struct T T;"
        - methods prototypes:   <tp_r> CEU_T__f (<tp_ps>);
        - accessors prototypes: <tp_f> _CEU_I__f (I* i);
        - field accessors
        - struct
        - cstruct
        - host (+methods)
    - main cls

=== LABELS_ENUM

tceu

=== IFCS_ACCS
*/

#include <string.h>
#include <limits.h>

#ifdef CEU_DEBUG
#include <assert.h>
#include <signal.h>
#include <stdlib.h>
#endif

#if defined(CEU_NEWS) || defined(CEU_THREADS)
#include <stdlib.h>     /* malloc / free */
#endif

#ifdef CEU_NEWS
=== POOL_C ===
#endif

#ifdef __cplusplus
#define CEU_WCLOCK_INACTIVE 0x7fffffffL     /* TODO */
#else
#define CEU_WCLOCK_INACTIVE INT32_MAX
#endif
#define CEU_WCLOCK_EXPIRED (CEU_WCLOCK_INACTIVE-1)

#define CEU_NMEM       (=== CEU_NMEM ===)
#define CEU_NTRAILS    (=== CEU_NTRAILS ===)

#ifdef CEU_IFCS
#include <stddef.h>
/* TODO: === direto? */
#define CEU_NCLS       (=== CEU_NCLS ===)
#define CEU_IFC_CLS(tp,org,idx) ((tp)CEU.ifcs_flds[org][idx])
#endif

/* Macros that can be defined:
 * ceu_out_pending() (sync?)
 * ceu_out_wclock(dt)
 * ceu_out_event(id, len, data)
 * ceu_out_async(more?);
 * ceu_out_end(v)
 */

#ifdef CEU_THREADS
#ifndef CEU_THREADS_T
#include <pthread.h>
#define CEU_THREADS_T               pthread_t
#define CEU_THREADS_MUTEX_T         pthread_mutex_t
#define CEU_THREADS_COND_T          pthread_cond_t
#define CEU_THREADS_SELF()          pthread_self()
#define CEU_THREADS_CREATE(t,f,p)   pthread_create(t,NULL,f,p)
#define CEU_THREADS_DETACH(t)       pthread_detach(t)
/*
#define CEU_THREADS_MUTEX_LOCK(m)   pthread_mutex_lock(m); printf("L[%d]\n",__LINE__)
#define CEU_THREADS_MUTEX_UNLOCK(m) pthread_mutex_unlock(m); printf("U[%d]\n",__LINE__)
*/
#define CEU_THREADS_MUTEX_LOCK(m)   pthread_mutex_lock(m)
#define CEU_THREADS_MUTEX_UNLOCK(m) pthread_mutex_unlock(m);
#define CEU_THREADS_COND_WAIT(c,m)  pthread_cond_wait(c,m)
#define CEU_THREADS_COND_SIGNAL(c)  pthread_cond_signal(c)
#endif
#endif

#ifdef CEU_THREADS
#   define CEU_ATOMIC(f)                                \
            CEU_THREADS_MUTEX_LOCK(&CEU.threads_mutex); \
                f                                       \
            CEU_THREADS_MUTEX_UNLOCK(&CEU.threads_mutex);
#else
#   define CEU_ATOMIC(f) f
#endif

/*
 * pthread_t thread;
 * pthread_mutex_t mutex;
 * pthread_cond_t  cond;
 * pthread_self();
        Uint32 SDL_ThreadID(void);
 * pthread_create(&thread, NULL, f, &p);
        SDL_Thread *SDL_CreateThread(int (*fn)(void *), void *data);
 * pthread_mutex_lock(&mutex);
 * pthread_mutex_unlock(&mutex);
 * pthread_cond_wait(&cond, &mutex);
 * pthread_cond_signal(&cond);
*/

/*typedef === TCEU_NEVT === tceu_nevt;    // (x) number of events */
typedef u8 tceu_nevt;    /* (x) number of events */

/* TODO: lbl => unsigned */
typedef === TCEU_NLBL === tceu_nlbl;    /* (x) number of trails */

#ifdef CEU_IFCS
typedef === TCEU_NCLS === tceu_ncls;    /* (x) number of instances */
#endif

/* align all structs 1 byte
// TODO: verify defaults for microcontrollers
//#pragma pack(push)
//#pragma pack(1)
*/

#define CEU_MAX_STACK   255     /* TODO */

typedef union tceu_trl {
    tceu_nevt evt;
    struct {                    /* TODO(ram): bitfields */
        tceu_nevt evt1;
        tceu_nlbl lbl;
        u8        seqno;        /* TODO(ram): 2 bits is enough */
    };
    struct {                    /* TODO(ram): bitfields */
        tceu_nevt evt2;
        tceu_nlbl lbl2;
        u8        stk;
    };
#ifdef CEU_ORGS
    struct {                    /* TODO(ram): bad for alignment */
        tceu_nevt evt3;
        struct tceu_lnk* lnks;
    };
#endif
} tceu_trl;

typedef union {
    int   v;
    void* ptr;
    s32   dt;
#ifdef CEU_THREADS
    CEU_THREADS_T thread;
#endif
} tceu_evtp;

/* TODO(speed): hold nxt trl to run */
typedef struct {
    tceu_evtp evtp;
#ifdef CEU_INTS
#ifdef CEU_ORGS
    void*     evto;
#endif
#endif
    tceu_nevt evt;
} tceu_stk;

typedef struct {
#ifdef CEU_ORGS
    void*     org;
#endif
    tceu_trl* trl;
    tceu_nlbl lbl;
} tceu_lst;

/* simulates an org prv/nxt */
typedef struct tceu_lnk {
    struct tceu_org* prv;   /* TODO(ram): lnks[0] does not use */
    struct tceu_org* nxt;   /*      prv, n, lnk                  */
    u8 n;                   /* use for ands/fins                 */
    u8 lnk;
} tceu_lnk;

typedef struct tceu_org
{
#ifdef CEU_ORGS
    struct tceu_org* prv;   /* linked list for the scheduler */
    struct tceu_org* nxt;
    u8 n;                   /* number of trails (TODO(ram): opt, metadata) */
    u8 lnk;
    /* tceu_lnk */

#ifdef CEU_IFCS
    tceu_ncls cls;          /* class id */
#endif

#ifdef CEU_NEWS
    u8 isDyn: 1;            /* created w/ new or spawn? */
    u8 isSpw: 1;            /* free on termination? */
#endif
#endif  /* CEU_ORGS */

#ifdef CEU_NEWS_POOL
    void*  pool;            /* TODO(ram): opt, traverse lst of cls pools */
#endif

    tceu_trl trls[0];       /* first trail */

} tceu_org;

/* class definitions */
=== CLSS_DEFS ===

/* goto labels */
enum {
=== LABELS_ENUM ===
};

typedef struct {
#ifdef CEU_WCLOCKS
    int         wclk_late;
    s32         wclk_min;
    s32         wclk_min_tmp;
#endif

#ifdef CEU_IFCS
    s8    ifcs_clss[CEU_NCLS][=== IFCS_NIFCS ===]; /* TODO(ram): bitfield */
    u16   ifcs_flds[CEU_NCLS][=== IFCS_NFLDS ===];
    u16   ifcs_evts[CEU_NCLS][=== IFCS_NEVTS ===];
#endif

#ifdef CEU_DEBUG
    tceu_lst    lst; /* segfault printf */
#endif

#ifdef CEU_THREADS
    CEU_THREADS_MUTEX_T threads_mutex;
    CEU_THREADS_COND_T  threads_cond;
#endif

    CEU_Main    mem;
} tceu;

/* TODO: fields that need no initialization? */

tceu CEU = {
#ifdef CEU_WCLOCKS
    0, CEU_WCLOCK_INACTIVE, CEU_WCLOCK_INACTIVE,
#endif
#ifdef CEU_IFCS
    {
=== IFCS_CLSS ===
    },
    {
=== IFCS_FLDS ===
    },
    {
=== IFCS_EVTS ===
    },
#endif
#ifdef CEU_DEBUG
    {},
#endif
#ifdef CEU_THREADS
    PTHREAD_MUTEX_INITIALIZER,
    PTHREAD_COND_INITIALIZER,
#endif
    {}                          /* TODO: o q ele gera? */
};

#ifdef CEU_IFCS
/* iterface accessors */
=== IFCS_ACCS ===   /* requires CEU.ifcs_flds */
#endif

/*#pragma pack(pop) */

/**********************************************************************/

void ceu_go (int _ceu_evt, tceu_evtp _ceu_evtp);

/**********************************************************************/

#ifdef CEU_WCLOCKS

void ceu_wclocks_min (s32 dt, int out) {
    if (CEU.wclk_min > dt) {
        CEU.wclk_min = dt;
#ifdef ceu_out_wclock
        if (out)
            ceu_out_wclock(dt);
#endif
    }
}

int ceu_wclocks_expired (s32* t, s32 dt) {
    if (*t>CEU.wclk_min_tmp || *t>dt) {
        *t -= dt;
        ceu_wclocks_min(*t, 0);
        return 0;
    }
    return 1;
}

void ceu_trails_set_wclock (s32* t, s32 dt) {
    s32 dt_ = dt - CEU.wclk_late;
    *t = dt_;
    ceu_wclocks_min(dt_, 1);
}

#endif  /* CEU_WCLOCKS */

/**********************************************************************/

#ifdef CEU_NEWS
#ifdef CEU_RUNTESTS
/* TODO */
int _ceu_dyns_ = 0;
#endif
#endif

/**********************************************************************/

#ifdef CEU_DEBUG
void ceu_segfault (int sig_num) {
#ifdef CEU_ORGS
    fprintf(stderr, "SEGFAULT on %p : %d\n", CEU.lst.org, CEU.lst.lbl);
#else
    fprintf(stderr, "SEGFAULT on %d\n", CEU.lst.lbl);
#endif
    exit(0);
}
#endif

/**********************************************************************/

void ceu_org_init (tceu_org* org, int n, int lbl, int seqno,
                   tceu_org* par_org, int par_trl)
{
    /* { evt=0, seqno=0, lbl=0 } for all trails */
#ifdef CEU_ORGS
    org->n = n;
#endif
    memset(&org->trls, 0, n*sizeof(tceu_trl));

    /* org.trls[0] == org.blk.trails[1] */
    org->trls[0].evt   = CEU_IN__STK;
    org->trls[0].lbl   = lbl;
    org->trls[0].seqno = seqno;

#ifdef CEU_ORGS
    if (par_org == NULL)
        return;             /* main class */

    /* re-link */
    {
        tceu_lnk* lst = &par_org->trls[par_trl].lnks[1];
        lst->prv->nxt = org;
        org->prv = lst->prv;
        org->nxt = (tceu_org*)lst;
        lst->prv = org;
    }
#endif  /* CEU_ORGS */
}
#ifndef CEU_ORGS
#define ceu_org_init(a,b,c,d,e,f) ceu_org_init(a,b,c,d,NULL,0)
#endif

/**********************************************************************/

#ifdef CEU_PSES
void ceu_pause (tceu_trl* trl, tceu_trl* trlF, int psed) {
    do {
        if (psed) {
            if (trl->evt == CEU_IN__ORG)
                trl->evt = CEU_IN__ORG_PSED;
        } else {
            if (trl->evt == CEU_IN__ORG_PSED)
                trl->evt = CEU_IN__ORG;
        }
        if ( trl->evt == CEU_IN__ORG
        ||   trl->evt == CEU_IN__ORG_PSED ) {
            trl += 2;       /* jump [fst|lst] */
        }
    } while (++trl <= trlF);

#ifdef ceu_out_wclock
    if (!psed) {
        ceu_out_wclock(0);  /* TODO: recalculate MIN clock */
                            /*       between trl => trlF   */
    }
#endif
}
#endif

/**********************************************************************/

void ceu_go_init ()
{
#ifdef CEU_DEBUG
    signal(SIGSEGV, ceu_segfault);
#endif
#ifdef CEU_NEWS
    === CLSS_POOLS ===
#endif
    ceu_org_init((tceu_org*)&CEU.mem, CEU_NTRAILS, Class_Main, 0, NULL, 0);
    {
        tceu_evtp p;
        p.ptr = NULL;
        ceu_go(CEU_IN__INIT, p);
    }
}

/* TODO: ret */

#ifdef CEU_EXTS
void ceu_go_event (int id, void* data)
{
#ifdef CEU_DEBUG_TRAILS
    fprintf(stderr, "====== %d\n", id);
#endif
    {
        tceu_evtp p;
        p.ptr = data;
        ceu_go(id, p);
    }
}
#endif

#ifdef CEU_ASYNCS
void ceu_go_async ()
{
#ifdef CEU_DEBUG_TRAILS
    fprintf(stderr, "====== ASYNC\n");
#endif
    {
        tceu_evtp p;
        p.ptr = NULL;
        ceu_go(CEU_IN__ASYNC, p);
    }
}
#endif

void ceu_go_wclock (s32 dt)
{
#ifdef CEU_WCLOCKS

#ifdef CEU_DEBUG_TRAILS
    fprintf(stderr, "====== WCLOCK\n");
#endif

    if (CEU.wclk_min <= dt)
        CEU.wclk_late = dt - CEU.wclk_min;   /* how much late the wclock is */

    CEU.wclk_min_tmp = CEU.wclk_min;
    CEU.wclk_min     = CEU_WCLOCK_INACTIVE;

    {
        tceu_evtp p;
        p.dt = dt;
        ceu_go(CEU_IN__WCLOCK, p);
    }

#ifdef ceu_out_wclock
    if (CEU.wclk_min != CEU_WCLOCK_INACTIVE)
        ceu_out_wclock(CEU.wclk_min);   /* only signal after all */
#endif

    CEU.wclk_late = 0;

#endif   /* CEU_WCLOCKS */

    return;
}

void ceu_go_all (int* ret_end)
{
    /* All code run atomically:
     * - the program is always locked as a whole
     * -    thread spawns will unlock => re-lock
     * - but program will still run to completion
     * - only COND_WAIT will allow threads to execute
     */

#ifdef CEU_THREADS
    CEU_THREADS_MUTEX_LOCK(&CEU.threads_mutex);
#endif

    ceu_go_init();
    if (ret_end!=NULL && *ret_end) goto _CEU_END_;

#ifdef CEU_IN_START
    ceu_go_event(CEU_IN_START, NULL);
    if (ret_end!=NULL && *ret_end) goto _CEU_END_;
#endif

#ifdef CEU_ASYNCS
    for (;;) {
        ceu_go_async();
#ifdef CEU_THREADS
        CEU_THREADS_MUTEX_UNLOCK(&CEU.threads_mutex);
        /* allow threads to also execute */
        CEU_THREADS_MUTEX_LOCK(&CEU.threads_mutex);
#endif
        if (ret_end!=NULL && *ret_end) goto _CEU_END_;
    }
#endif

#ifdef CEU_THREADS
    for (;;) {
        if (ret_end!=NULL && *ret_end) goto _CEU_END_;
        CEU_THREADS_COND_WAIT(&CEU.threads_cond, &CEU.threads_mutex);
    }
#endif

_CEU_END_:;
#ifdef CEU_THREADS
    CEU_THREADS_MUTEX_UNLOCK(&CEU.threads_mutex);
#endif
#ifdef CEU_NEWS
#ifdef CEU_RUNTESTS
    #define CEU_MAX_DYNS 100
/*fprintf(stderr, "XXX %d\n", _ceu_dyns_); */
    assert(_ceu_dyns_ == 0);
#endif
#endif
}

#ifdef CEU_RUNTESTS
void ceu_stack_clr () {
    int a[1000];
    memset(a, 0, sizeof(a));
}
#endif

#undef _ceu_org
#ifdef CEU_THREADS
typedef struct {
    tceu_org* org;
    s8*       st; /* thread state:
                   * 0=ini (sync  spawns)
                   * 1=cpy (async copies)
                   * 2=lck (sync  locks)
                   * 3=end (sync/async terminates)
                   */
} tceu_threads_p;

/* THREADS bodies (C functions)
void* f (tceu_threads_p* p) {
}
 */
=== THREADS_C ===
#endif

void ceu_go (int _ceu_evt, tceu_evtp _ceu_evtp)
{
#ifdef CEU_INTS
#ifdef CEU_ORGS
    tceu_org* _ceu_evto;       /* org that emitted current event */
#endif
#endif

#ifdef CEU_ORGS
    /* TODO: CEU_ORGS is calculable // CEU_NEWS isn't (255?) */
    tceu_stk _CEU_STK[CEU_MAX_STACK];
#else
    tceu_stk _CEU_STK[CEU_NTRAILS];
#endif

    /* global seqno: incremented on every reaction
     * awaiting trails matches only if trl->seqno < seqno,
     * i.e., previously awaiting the event
     */
    static u8 _ceu_seqno = 0;

    /* current traversal state */
    int       _ceu_stki = 0;   /* points to next */
    tceu_trl* _ceu_trl;
    tceu_nlbl _ceu_lbl;
#ifdef CEU_ORGS
    tceu_org* _ceu_org;
#else
    #define   _ceu_org ((tceu_org*)&CEU.mem)
#endif

    /* traversals may be bounded to org/trl
     * default (NULL) is to traverse everything */
#ifdef CEU_CLEAR
    void* _ceu_stop = NULL;     /* stop at this trl/org */
#endif

    _ceu_seqno++;

    for (;;)    /* STACK */
    {
#ifdef CEU_ORGS
        /* TODO: don't restart if kill is impossible (hold trl on stk) */
        _ceu_org = (tceu_org*) &CEU.mem;    /* on pop(), always restart */
#endif
#if defined(CEU_INTS) || defined(CEU_ORGS)
_CEU_CALL_:
#endif
        /* restart from org->trls[0] */
        _ceu_trl = &_ceu_org->trls[0];

#if defined(CEU_CLEAR) || defined(CEU_ORGS)
_CEU_CALLTRL_:  /* restart from org->trls[i] */
#endif

#ifdef CEU_DEBUG_TRAILS
#ifdef CEU_ORGS
fprintf(stderr, "GO[%d]: evt=%d stk=%d org=%p [%d/%p]\n", _ceu_seqno,
                _ceu_evt, _ceu_stki, _ceu_org, _ceu_org->n, _ceu_org->trls);
#else
fprintf(stderr, "GO[%d]: evt=%d stk=%d [%d]\n", _ceu_seqno,
                _ceu_evt, _ceu_stki, CEU_NTRAILS);
#endif
#endif
        for (;;) /* TRL // TODO(speed): only range of trails that apply */
        {        /* (e.g. events that do not escape an org) */
#ifdef CEU_CLEAR
            if (_ceu_trl == _ceu_stop) {    /* bounded trail traversal? */
                _ceu_stop = NULL;           /* back to default */
                break;                      /* pop stack */
            }
#endif

            /* _ceu_org has been traversed to the end? */
            if (_ceu_trl ==
                &_ceu_org->trls[
#ifdef CEU_ORGS
                    _ceu_org->n
#else
                    CEU_NTRAILS
#endif
                ])
            {
                if (_ceu_org == (tceu_org*) &CEU.mem) {
                    break;  /* pop stack */
                }

#ifdef CEU_ORGS
                {
                    /* hold next org/trl */
                    /* TODO(speed): jump LST */
                    tceu_org* _org = _ceu_org->nxt;
                    tceu_trl* _trl = &_org->trls [
                                        (_ceu_org->n == 0) ?
                                         ((tceu_lnk*)_ceu_org)->lnk : 0
                                      ];

#ifdef CEU_NEWS
                    /* org has been cleared to the end? */
                    if ( _ceu_evt == CEU_IN__CLEAR
                    &&   _ceu_org->isDyn
                    &&   _ceu_org->n != 0 )  /* TODO: avoids LNKs */
                    {
                        /* re-link PRV <-> NXT */
                        _ceu_org->prv->nxt = _ceu_org->nxt;
                        _ceu_org->nxt->prv = _ceu_org->prv;

                        /* FREE */
                        /* TODO: check if needed? (freed manually?) */
                        /*fprintf(stderr, "FREE: %p\n", _ceu_org);*/
                        /* TODO(speed): avoid free if pool and blk out of scope */
#if    defined(CEU_NEWS_POOL) && !defined(CEU_NEWS_MALLOC)
                        ceu_pool_free(_ceu_org->pool, (char*)_ceu_org);
#elif  defined(CEU_NEWS_POOL) &&  defined(CEU_NEWS_MALLOC)
                        if (_ceu_org->pool == NULL)
                            free(_ceu_org);
                        else
                            ceu_pool_free(_ceu_org->pool, _ceu_org);
#elif !defined(CEU_NEWS_POOL) &&  defined(CEU_NEWS_MALLOC)
                        free(_ceu_org);
#endif
#ifdef CEU_RUNTESTS
                        _ceu_dyns_--;
#endif

                        /* explicit free(me) or end of spawn */
                        if (_ceu_stop == _ceu_org)
                            break;  /* pop stack */
                    }
#endif  /* CEU_NEWS */

                    _ceu_org = _org;
                    _ceu_trl = _trl;
/*fprintf(stderr, "UP[%p] %p %p\n", trl+1, _ceu_org _ceu_trl);*/
                    goto _CEU_CALLTRL_;
                }
#endif  /* CEU_ORGS */
            }

            /* continue traversing CUR org */
            {
#ifdef CEU_DEBUG_TRAILS
#ifdef CEU_ORGS
if (_ceu_trl->evt==CEU_IN__ORG)
    fprintf(stderr, "\tTRY [%p] : evt=%d org=%p->%p\n",
                    _ceu_trl, _ceu_trl->evt,
                    &_ceu_trl->lnks[0], &_ceu_trl->lnks[1]);
else
#endif
fprintf(stderr, "\tTRY [%p] : evt=%d seqno=%d lbl=%d\n",
                    _ceu_trl, _ceu_trl->evt, _ceu_trl->seqno, _ceu_trl->lbl);
#endif

                /* jump into linked orgs */
#ifdef CEU_ORGS
                if ( (_ceu_trl->evt == CEU_IN__ORG)
#ifdef CEU_PSES
                  || (_ceu_trl->evt==CEU_IN__ORG_PSED && _ceu_evt==CEU_IN__CLEAR)
#endif
                   )
                {
                    /* TODO(speed): jump LST */
                    _ceu_org = _ceu_trl->lnks[0].nxt;   /* jump FST */
                    if (_ceu_evt == CEU_IN__CLEAR) {
                        _ceu_trl->evt = CEU_IN__NONE;
                    }
                    goto _CEU_CALL_;
                }
#endif /* CEU_ORGS */

                switch (_ceu_evt)
                {
                    /* "clear" event */
                    case CEU_IN__CLEAR:
                        if (_ceu_trl->evt == CEU_IN__CLEAR)
                            goto _CEU_GO_;
                        _ceu_trl->evt = CEU_IN__NONE;
                        goto _CEU_NEXT_;
                }

                /* a continuation (STK) will always appear before a
                 * matched event in the same stack level
                 */
                if ( ! (
                    (_ceu_trl->evt==CEU_IN__STK && _ceu_trl->stk==_ceu_stki)
                ||
                    (_ceu_trl->evt==_ceu_evt    && _ceu_trl->seqno!=_ceu_seqno)
                    /* _ceu_evt!=CEU_IN__STK (never generated): comp is safe */
                    /* we use `!=´ intead of `<´ due to u8 overflow */
                ) ) {
                    goto _CEU_NEXT_;
                }
_CEU_GO_:
                /* execute this trail */
                _ceu_trl->evt   = CEU_IN__NONE;
                _ceu_trl->seqno = _ceu_seqno;   /* don't awake again */
                _ceu_lbl = _ceu_trl->lbl;
            }

#ifdef CEU_GOTO
_CEU_GOTO_:
#endif
#ifdef CEU_DEBUG
#ifdef CEU_ORG
    CEU.lst.org = _ceu_org;
#endif
    CEU.lst.trl = _ceu_trl;
    CEU.lst.lbl = _ceu_lbl;
#ifdef CEU_DEBUG_TRAILS
#ifdef CEU_ORGS
fprintf(stderr, "TRK: o.%p / l.%d\n", _ceu_org, _ceu_lbl);
#else
fprintf(stderr, "TRK: l.%d\n", _ceu_lbl);
#endif
#endif
#endif

#ifdef CEU_RUNTESTS
        ceu_stack_clr();
#endif

            switch (_ceu_lbl) {
                === CODE ===
            }
_CEU_NEXT_:
            /* _ceu_trl!=CEU_IN__ORG guaranteed here */
            if (_ceu_trl->evt!=CEU_IN__STK && _ceu_trl->seqno!=_ceu_seqno)
                _ceu_trl->seqno = _ceu_seqno-1;   /* keeps the gap tight */
            _ceu_trl++;
        }

        if (_ceu_stki == 0) {
            break;      /* reaction has terminated */
        }
        _ceu_evtp = _CEU_STK[--_ceu_stki].evtp;
#ifdef CEU_INTS
#ifdef CEU_ORGS
        _ceu_evto = _CEU_STK[  _ceu_stki].evto;
#endif
#endif
        _ceu_evt  = _CEU_STK[  _ceu_stki].evt;
    }
}
]===]

    local sub = function (str, from, to)
        assert(to, from)
        local i,e = string.find(str, from)
        return string.sub(str, 1, i-1) .. to .. string.sub(str, e+1)
    end

    tpl = sub(tpl, '=== CEU_NTRAILS ===',  _MAIN.trails_n)

    tpl = sub(tpl, '=== TCEU_NLBL ===',    's'..tps[_ENV.c.tceu_nlbl.len])

    tpl = sub(tpl, '=== LABELS_ENUM ===', _LBLS.code_enum)

    tpl = sub(tpl, '=== POOL_C ===', [===[/*
 * Ceu pool.c is based on Contiki and TinyOS pools:
 * https://github.com/contiki-os/contiki/blob/master/core/lib/memb.c
 * https://github.com/tinyos/tinyos-main/blob/master/tos/system/PoolP.nc
 */

typedef struct {
    int     size;
    int     free;
    int     index;
    int     unit;
    char** queue;
    char*  mem;
} tceu_pool;

#define CEU_POOL_DCL(name, type, size) \
    type* name##_queue[size];          \
    type  name##_mem[size];            \
    tceu_pool name;

void ceu_pool_init (tceu_pool* pool, int size, int unit,
                    char** queue, char* mem)
{
    int i;
    pool->size  = size;
    pool->free  = size;
    pool->index = 0;
    pool->unit  = unit;
    pool->queue = queue;
    pool->mem   = mem;
    for (i=0; i<size; i++) {
        queue[i] = &mem[i*unit];
    }
}

char* ceu_pool_alloc (tceu_pool* pool) {
    char* ret;

    if (pool->free == 0) {
        return NULL;
    }

    pool->free--;
    ret = pool->queue[pool->index];
    pool->queue[pool->index++] = NULL;
    if (pool->index == pool->size) {
        pool->index = 0;
    }
    return ret;
}

void ceu_pool_free (tceu_pool* pool, char* val) {
    int empty = pool->index + pool->free;
    if (empty >= pool->size) {
        empty -= pool->size;
    }
    pool->queue[empty] = val;
    pool->free++;
}

/*
int ceu_pool_inside (tceu_pool* pool, char* val) {
    return ((char*)val >= pool->mem)
        && ((char*)val < pool->mem+(pool->size*pool->unit));
}
*/
]===])
    tpl = sub(tpl, '=== CLSS_DEFS ===',  _MEM.clss_defs)
    tpl = sub(tpl, '=== CLSS_POOLS ===', _MEM.clss_pools)
    tpl = sub(tpl, '=== IFCS_ACCS ===',  _MEM.ifcs_accs)

    tpl = sub(tpl, '=== THREADS_C ===', _CODE.threads)
    --tpl = sub(tpl, '=== HOST ===',     _CODE.host)
    tpl = sub(tpl, '=== CODE ===',     _AST.root.code)

    -- IFACES
    if _PROPS.has_ifcs then
        local CLSS = {}
        local FLDS = {}
        local EVTS = {}
        for _, cls in ipairs(_ENV.clss_cls) do
            local clss = {}
            local flds = {}
            local evts = {}
            for i=1, #_ENV.ifcs.flds do
                flds[i] = 0
            end
            for i=1, #_ENV.ifcs.evts do
                evts[i] = 0
            end
            for _, var in ipairs(cls.blk_ifc.vars) do
                if var.isEvt then
                    local i = _ENV.ifcs.evts[var.ifc_id]
                    if i then
                        evts[i+1] = var.evt_idx
                    end
                else
                    local i = _ENV.ifcs.flds[var.ifc_id]
                    if i then
                        flds[i+1] = 'offsetof(CEU_'..cls.id..','..var.id_..')'
                    end
                end
            end

            -- IFCS_CLSS
            for _,ifc in ipairs(_ENV.clss_ifc) do
                clss[#clss+1] = cls.matches[ifc] and 1 or 0
            end

            CLSS[#CLSS+1] = '\t\t{'..table.concat(clss,',')..'}'
            FLDS[#FLDS+1] = '\t\t{'..table.concat(flds,',')..'}'
            EVTS[#EVTS+1] = '\t\t{'..table.concat(evts,',')..'}'
        end
        tpl = sub(tpl, '=== TCEU_NCLS ===',    'u'..tps[_ENV.c.tceu_ncls.len])
        tpl = sub(tpl, '=== CEU_NCLS ===',     #_ENV.clss_cls)
        tpl = sub(tpl, '=== IFCS_NIFCS ===',   #_ENV.clss_ifc)
        tpl = sub(tpl, '=== IFCS_NFLDS ===',   #_ENV.ifcs.flds)
        tpl = sub(tpl, '=== IFCS_NEVTS ===',   #_ENV.ifcs.evts)
        tpl = sub(tpl, '=== IFCS_CLSS ===',    table.concat(CLSS,',\n'))
        tpl = sub(tpl, '=== IFCS_FLDS ===',    table.concat(FLDS,',\n'))
        tpl = sub(tpl, '=== IFCS_EVTS ===',    table.concat(EVTS,',\n'))
    end

    -- EVENTS
    -- inputs: [max_evt+1...) (including _FIN,_WCLOCK,_ASYNC)
    --          cannot overlap w/ internal events
    local str = ''
    local t = {}
    --local ins  = 0
    local outs = 0

    -- TODO
    str = str..'#define CEU_IN__NONE 0\n'

    for i, evt in ipairs(_ENV.exts) do
        if evt.pre == 'input' then
            str = str..'#define CEU_IN_'..evt.id..' '
                    ..(_ENV.max_evt+i)..'\n'
            --ins = ins + 1
        else
            str = str..'#define CEU_OUT_'..evt.id..' '..outs..'\n'
            outs = outs + 1
        end
        assert(evt.pre=='input' or evt.pre=='output')
    end
    --str = str..'#define CEU_IN_n  '..ins..'\n'
    str = str..'#define CEU_OUT_n '..outs..'\n'

    -- FUNCTIONS called
    for id in pairs(_ENV.calls) do
        if id ~= '$anon' then
            str = str..'#define CEU_FUN'..id..'\n'
        end
    end

    -- DEFINES
    local t = {
        has_exts    = 'CEU_EXTS',
        has_wclocks = 'CEU_WCLOCKS',
        has_ints    = 'CEU_INTS',
        has_asyncs  = 'CEU_ASYNCS',
        has_threads = 'CEU_THREADS',
        has_orgs    = 'CEU_ORGS',
        has_news    = 'CEU_NEWS',
        has_news_pool   = 'CEU_NEWS_POOL',
        has_news_malloc = 'CEU_NEWS_MALLOC',
        has_ifcs    = 'CEU_IFCS',
        has_clear   = 'CEU_CLEAR',
        has_pses    = 'CEU_PSES',
    }
    for k, s in pairs(t) do
        if _PROPS[k] then
            str = str .. '#define ' .. s .. '\n'
        end
    end

    if _CODE.has_goto then
        str = str .. '#define CEU_GOTO\n'
    end

    -- TODO: goto _OPTS
    --str = str .. '#define CEU_DEBUG_TRAILS\n'
    --str = str .. '#define CEU_NOLINES\n'

    if _OPTS.run_tests then
        str = str .. '#define CEU_RUNTESTS\n'
    end

    -- tuples
    do
        for _,c in pairs(_ENV.c) do
            if c.tuple then
                str = str .. 'typedef struct {\n'
                for i, tp in ipairs(c.tuple) do
                    if _ENV.clss[_TP.noptr(tp)] then
                        -- T* => void*
                        -- T** => void**
                        tp = 'void'..string.match(tp,'(%*+)')
                    end
                    str = str..'\t'.._TP.c(tp)..' _'..i..';\n'
                end
                str = str .. '} '.._TP.c(c.id)..';\n'
            end
        end
    end

    if _OPTS.defs_file then
        local f = assert(io.open(_OPTS.defs_file,'w'))
        local h = [[
#ifndef _CEU_DEFS_H
#define _CEU_DEFS_H
void ceu_go_init ();
void ceu_go_event (int id, void* data);
void ceu_go_async ();
void ceu_go_wclock (s32 dt);
]]
        f:write(h..str..[[
#endif
]])
        f:close()
        tpl = sub(tpl, '=== DEFS ===',
                       '#include "'.. _OPTS.defs_file ..'"')
    else
        tpl = sub(tpl, '=== DEFS ===', str)
    end

    tpl = sub(tpl, '=== FILENAME ===', _OPTS.input)

    --tpl = string.gsub(tpl, '^#line.-\n', '')
end

if _OPTS.verbose or true then
    local T = {
        --mem  = _AST.root.mem.max,
        evts = _ENV.max_evt+#_ENV.exts,
        lbls = #_LBLS.list,

        trls       = _AST.root.trails_n,

        exts    = _PROPS.has_exts,
        wclocks = _PROPS.has_wclocks,
        ints    = _PROPS.has_ints,
        asyncs  = _PROPS.has_asyncs,
        orgs    = _PROPS.has_orgs,
        news    = _PROPS.has_news,
        ifcs    = _PROPS.has_ifcs,
    }
    local t = {}
    for k, v in pairs(T) do
        if v == true then
            t[#t+1] = k
        elseif v then
            t[#t+1] = k..'='..v
        end
    end
    table.sort(t)
    DBG('[ '..table.concat(t,' | ')..' ]')
end

-- OUTPUT
local out
if _OPTS.output == '-' then
    out = io.stdout
else
    out = assert(io.open(_OPTS.output,'w'))
end
out:write([[
/*
 * This file is automatically generated.
 * Check the github repository for a readable version:
 * http://github.com/fsantanna/ceu
 *
 * Céu is distributed under the MIT License:
 *

Copyright (C) 2012 Francisco Sant'Anna

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/
]] .. tpl)
